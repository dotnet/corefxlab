<#@ template debug="true" hostSpecific="true" #>
<#@ assembly Name="System.Core.dll" #>
<#@ import namespace="System" #>
<#@ import namespace="System.Linq" #>
<#@ output extension=".cs" #>
<#@ include file="RangeConfig.ttinclude" #><# GenerateCopyrightHeader(); #>

using System.Collections.Generic;
using System.Runtime.CompilerServices;

namespace System
{
    public static class RangeExtensions
    {
        #region Helpers

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool FromLessThan<T>(T left, T right, IComparer<T> comparer)
        {
            if (left == null) return true;
            if (right == null) return false;
            return comparer.Compare(left, right) < 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool FromLessThanOrEquals<T>(T left, T right, IComparer<T> comparer)
        {
            if (left == null) return true;
            if (right == null) return false;
            return comparer.Compare(left, right) <= 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool ToLessThan<T>(T left, T right, IComparer<T> comparer)
        {
            if (right == null) return true;
            if (left == null) return false;
            return comparer.Compare(left, right) < 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool ToLessThanOrEquals<T>(T left, T right, IComparer<T> comparer)
        {
            if (right == null) return true;
            if (left == null) return false;
            return comparer.Compare(left, right) <= 0;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool FromLessThanTo<T>(T left, T right, IComparer<T> comparer)
        {
            if (left == null || right == null) return true;
            return comparer.Compare(left, right) < 0;
        }

        #endregion

        #region IsEmpty Methods

        public static bool IsEmpty<T>(this Range<T> range)
            => IsEmptyImpl(range, Comparer<T>.Default);

        public static bool IsEmpty<T>(this Range<T> range, IComparer<T> comparer)
            => IsEmptyImpl(range, comparer ?? Comparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsEmptyImpl<T>(Range<T> range, IComparer<T> comparer)
        {
            if (range.From == null && range.To == null) return false;
            return comparer.Compare(range.From, range.To) == 0;
        }
<# 
    foreach (var type in SupportedTypes)
    {
#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsEmpty(this Range<<#= type.Name #>> range)
        {
            return range.From == range.To;
        }
<# 
    }
#>

        #endregion

        #region Length Methods
<# 
    foreach (var type in SupportedTypes.Where(t => HasLengthType(t)))
    {
        var lengthType = GetLengthType(type);
#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static <#=lengthType.Name#> Length(this Range<<#= type.Name #>> range)
        {
            return (<#= lengthType.Name #>)(range.To - range.From);
        }
<# 
    }
#>
        #endregion

        #region Normalization Methods

        public static bool IsNormalized<T>(this Range<T> range)
            => IsNormalizedImpl(range, Comparer<T>.Default);

        public static bool IsNormalized<T>(this Range<T> range, IComparer<T> comparer)
            => IsNormalizedImpl(range, comparer ?? Comparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IsNormalizedImpl<T>(Range<T> range, IComparer<T> comparer)
        {
            if (range.From == null || range.To == null) return true;
            return comparer.Compare(range.From, range.To) <= 0;
        }

        public static Range<T> Normalize<T>(this Range<T> range)
            => NormalizeImpl(range, Comparer<T>.Default);

        public static Range<T> Normalize<T>(this Range<T> range, IComparer<T> comparer)
            => NormalizeImpl(range, comparer ?? Comparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Range<T> NormalizeImpl<T>(Range<T> range, IComparer<T> comparer)
        {
            if (IsNormalizedImpl(range, comparer)) return range;
            return new Range<T>(range.To, range.From);
        }
<# 
    foreach (var type in SupportedTypes)
    {
#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool IsNormalized(this Range<<#= type.Name #>> range)
        {
            return range.To >= range.From;
        }

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static Range<<#= type.Name #>> Normalize(this Range<<#= type.Name #>> range)
        {
            return (range.To >= range.From) ? range : new Range<<#= type.Name #>>(range.To, range.From);
        }
<# 
    }
#>

        #endregion

        #region Contains Methods

        public static bool Contains<T>(this Range<T> range, T value)
            => ContainsImpl(range, value, Comparer<T>.Default);

        public static bool Contains<T>(this Range<T> range, T value, IComparer<T> comparer)
            => ContainsImpl(range, value, comparer ?? Comparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool ContainsImpl<T>(Range<T> range, T value, IComparer<T> comparer)
        {
            if (value == null) return false;
            return FromLessThanOrEquals(range.From, value, comparer) && ToLessThan(value, range.To, comparer);
        }
<# 
    foreach (var type in SupportedTypes)
    {
#>

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public static bool Contains(this Range<<#= type.Name #>> range, <#= type.Name #> value)
        {
            return range.From <= value && range.To > value;
        }
<# 
    }
#>

        #endregion

        #region Intersection Methods

        public static bool Intersects<T>(this Range<T> range, Range<T> other)
            => IntersectsImpl(range, other, Comparer<T>.Default);

        public static bool Intersects<T>(this Range<T> range, Range<T> other, IComparer<T> comparer)
            => IntersectsImpl(range, other, comparer ?? Comparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static bool IntersectsImpl<T>(Range<T> range, Range<T> other, IComparer<T> comparer)
        {
            return FromLessThanOrEquals(range.From, other.From, comparer)
                ? FromLessThanTo(other.From, range.To, comparer) && !IsEmptyImpl(other, comparer)
                : FromLessThanTo(range.From, other.To, comparer) && !IsEmptyImpl(range, comparer);
        }

        public static Range<T> Intersect<T>(this Range<T> range, Range<T> other)
            => IntersectImpl(range, other, Comparer<T>.Default);

        public static Range<T> Intersect<T>(this Range<T> range, Range<T> other, IComparer<T> comparer)
            => IntersectImpl(range, other, comparer ?? Comparer<T>.Default);

        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        private static Range<T> IntersectImpl<T>(Range<T> range, Range<T> other, IComparer<T> comparer)
        {
            var result = new Range<T>(
                FromLessThan(range.From, other.From, comparer) ? other.From : range.From,
                ToLessThan(range.To, other.To, comparer) ? range.To : other.To);
            if (IsNormalizedImpl(result, comparer)) return result;
            return new Range<T>(result.To, result.To);
        }
<# 
    foreach (var type in SupportedTypes)
    {
#>

        public static bool Intersects(this Range<<#= type.Name #>> range, Range<<#= type.Name #>> other)
        {
            return (range.From <= other.From)
                ? other.From != other.To && range.To > other.From
                : range.From != range.To && range.From < other.To;
        }

        public static Range<<#= type.Name #>> Intersect(this Range<<#= type.Name #>> range, Range<<#= type.Name #>> other)
        {
            if (range.From >= other.To || range.To <= other.From)
                return new Range<<#= type.Name #>>();

            return new Range<<#= type.Name #>>(
                (range.From > other.From) ? range.From : other.From,
                (range.To < other.To) ? range.To : other.To);
        }
<# 
    }
#>

        #endregion
    }
}
