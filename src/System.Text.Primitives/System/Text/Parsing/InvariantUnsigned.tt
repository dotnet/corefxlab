<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="PrimitiveParserHelpers.t4" #>
<#

List<IntegerTypeToParse> typesToParse = new List<IntegerTypeToParse>();

typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "byte", ClassName = "Byte", ValueCalculationTypeName = "uint" });
typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "ushort", ClassName = "UInt16", ValueCalculationTypeName = "uint" });
typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "uint", ClassName = "UInt32", ValueCalculationTypeName = "uint" });
typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "ulong", ClassName = "UInt64", ValueCalculationTypeName = "ulong" });

List<UtfEncoding> utfEncodings = new List<UtfEncoding> { UtfEncoding.Utf8, UtfEncoding.Utf16 };
List<bool> consumedParamTypes = new List<bool> { false, true };
List<BufferType> bufferTypes = new List<BufferType> { BufferType.ArrayPointer, BufferType.ReadOnlySpan };

#>
// Copyright (c) Microsoft. All rights reserved.
// Licensed under the MIT license. See LICENSE file in the project root for full license information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantUnsigned.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
<#
foreach (UtfEncoding utfEncoding in utfEncodings)
{
#>
        public static partial class Invariant<#=utfEncoding#>
        {
<#
    foreach (IntegerTypeToParse typeToParse in typesToParse)
    {
#>
            #region <#=typeToParse.ClassName#>
<#
        foreach (BufferType bufferType in bufferTypes)
        {
            foreach (bool consumedParamType in consumedParamTypes)
            {
                TryParseSignature tryParseSignature = new TryParseSignature(bufferType, consumedParamType, utfEncoding);
                TryParseIntegerOverload tryParseIntegerOverload = new TryParseIntegerOverload(typeToParse, tryParseSignature, false);
#>
            public <#=tryParseSignature.UnsafeModifier#>static bool TryParse<#=typeToParse.ClassName#>(<#=tryParseSignature.BufferParamsText#>, out <#=typeToParse.PrimitiveName#> value<#=tryParseSignature.ConsumedParamText#>)
            {
                if (<#=tryParseSignature.LengthName#> < 1)
                {
<#=tryParseIntegerOverload.SetOutParamsAndReturnFalse(5)#>
                }

                // Parse the first digit separately. If invalid here, we need to return false.
                <#=typeToParse.ValueCalculationTypeName#> firstDigit = text[0] - 48u; // '0'
                if (firstDigit > 9)
                {
<#=tryParseIntegerOverload.SetOutParamsAndReturnFalse(5)#>
                }
                <#=typeToParse.ValueCalculationTypeName#> parsedValue = firstDigit;

                if (<#=tryParseSignature.LengthName#> < <#=tryParseIntegerOverload.OverflowLengthName#>)
                {
                    // Length is less than <#=tryParseIntegerOverload.OverflowLengthName#>; overflow is not possible
                    for (int index = 1; index < <#=tryParseSignature.LengthName#>; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48u; // '0'
                        if (nextDigit > 9)
                        {
<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(false, 7)#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                }
                else
                {
                    // Length is greater than <#=tryParseIntegerOverload.OverflowLengthName#>; overflow is only possible after <#=tryParseIntegerOverload.OverflowLengthName#>
                    // digits. There may be no overflow after <#=tryParseIntegerOverload.OverflowLengthName#> if there are leading zeroes.
                    for (int index = 1; index < <#=tryParseIntegerOverload.OverflowLengthName#> - 1; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48u; // '0'
                        if (nextDigit > 9)
                        {
<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(false, 7)#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                    for (int index = <#=tryParseIntegerOverload.OverflowLengthName#> - 1; index < <#=tryParseSignature.LengthName#>; index++)
                    {
                        <#=typeToParse.ValueCalculationTypeName#> nextDigit = text[index] - 48u; // '0'
                        if (nextDigit > 9)
                        {
<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(false, 7)#>
                        }
                        // If parsedValue > (<#=typeToParse.PrimitiveName#>.MaxValue / 10), any more appended digits will cause overflow.
                        // if parsedValue == (<#=typeToParse.PrimitiveName#>.MaxValue / 10), any nextDigit greater than 5 implies overflow.
                        if (parsedValue > <#=typeToParse.PrimitiveName#>.MaxValue / 10 || (parsedValue == <#=typeToParse.PrimitiveName#>.MaxValue / 10 && nextDigit > 5))
                        {
<#=tryParseIntegerOverload.SetOutParamsAndReturnFalse(7)#>
                        }
                        parsedValue = parsedValue * 10 + nextDigit;
                    }
                }

<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(true, 4)#>
            }

<#
            }
        }
#>
            #endregion

<#
    }
#>
        }
<#
}
#>
    }
}