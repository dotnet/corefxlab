<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ include file="PrimitiveParserHelpers.t4" #>
<#

List<IntegerTypeToParse> typesToParse = new List<IntegerTypeToParse>();

typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "byte", ClassName = "Byte", ValueCalculationTypeName = "uint" });
typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "ushort", ClassName = "UInt16", ValueCalculationTypeName = "uint" });
typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "uint", ClassName = "UInt32", ValueCalculationTypeName = "uint" });
typesToParse.Add(new IntegerTypeToParse { PrimitiveName = "ulong", ClassName = "UInt64", ValueCalculationTypeName = "ulong" });

List<UtfEncoding> utfEncodings = new List<UtfEncoding> { UtfEncoding.Utf8, UtfEncoding.Utf16 };
List<bool> consumedParamTypes = new List<bool> { false, true };
List<BufferType> bufferTypes = new List<BufferType> { BufferType.ArrayPointer, BufferType.ReadOnlySpan };

#>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in InvariantUnsignedHex.tt.

namespace System.Text
{
    public static partial class PrimitiveParser
    {
<#
foreach (UtfEncoding utfEncoding in utfEncodings)
{
#>
        public static partial class Invariant<#=utfEncoding#>
        {
            public static partial class Hex
            {
<#
    foreach (IntegerTypeToParse typeToParse in typesToParse)
    {
#>
                #region <#=typeToParse.ClassName#>
<#
        foreach (BufferType bufferType in bufferTypes)
        {
            foreach (bool consumedParamType in consumedParamTypes)
            {
                TryParseSignature tryParseSignature = new TryParseSignature(bufferType, consumedParamType, utfEncoding);
                TryParseIntegerOverload tryParseIntegerOverload = new TryParseIntegerOverload(typeToParse, tryParseSignature, false);
#>
                public <#=tryParseSignature.UnsafeModifier#>static bool TryParse<#=typeToParse.ClassName#>(<#=tryParseSignature.BufferParamsText#>, out <#=typeToParse.PrimitiveName#> value<#=tryParseSignature.ConsumedParamText#>)
                {
                    if (<#=tryParseSignature.LengthName#> < 1)
                    {
<#=tryParseIntegerOverload.SetOutParamsAndReturnFalse(6)#>
                    }
                    <#=tryParseSignature.CharacterPrimitive#> nextCharacter;
                    byte nextDigit;

                    // Cache s_hexLookup in order to avoid static constructor checks
                    byte[] hexLookup = s_HexLookup;

                    // Parse the first digit separately. If invalid here, we need to return false.
<#=tryParseIntegerOverload.ParseOneHexCharacter("0", 5)#>
                    {
<#=tryParseIntegerOverload.SetOutParamsAndReturnFalse(6)#>
                    }
                    <#=typeToParse.ValueCalculationTypeName#> parsedValue = nextDigit;

                    if (<#=tryParseSignature.LengthName#> <= <#=tryParseIntegerOverload.OverflowLengthName#>Hex)
                    {
                        // Length is less than or equal to <#=tryParseIntegerOverload.OverflowLengthName#>Hex; overflow is not possible
                        for (int index = 1; index < <#=tryParseSignature.LengthName#>; index++)
                        {
<#=tryParseIntegerOverload.ParseOneHexCharacter("index", 7)#>
                            {
<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(false, 8)#>
                            }
                            parsedValue = (parsedValue << 4) + nextDigit;
                        }
                    }
                    else
                    {
                        // Length is greater than <#=tryParseIntegerOverload.OverflowLengthName#>Hex; overflow is only possible after <#=tryParseIntegerOverload.OverflowLengthName#>Hex
                        // digits. There may be no overflow after <#=tryParseIntegerOverload.OverflowLengthName#>Hex if there are leading zeroes.
                        for (int index = 1; index < <#=tryParseIntegerOverload.OverflowLengthName#>Hex; index++)
                        {
<#=tryParseIntegerOverload.ParseOneHexCharacter("index", 7)#>
                            {
<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(false, 8)#>
                            }
                            parsedValue = (parsedValue << 4) + nextDigit;
                        }
                        for (int index = <#=tryParseIntegerOverload.OverflowLengthName#>Hex; index < <#=tryParseSignature.LengthName#>; index++)
                        {
<#=tryParseIntegerOverload.ParseOneHexCharacter("index", 7)#>
                            {
<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(false, 8)#>
                            }
                            // If we try to append a digit to anything larger than <#=typeToParse.PrimitiveName#>.MaxValue / 0x10, there will be overflow
                            if (parsedValue > <#=typeToParse.PrimitiveName#>.MaxValue / 0x10)
                            {
<#=tryParseIntegerOverload.SetOutParamsAndReturnFalse(8)#>
                            }
                            parsedValue = (parsedValue << 4) + nextDigit;
                        }
                    }

<#=tryParseIntegerOverload.SetOutParamsAndReturnTrue(true, 5)#>
                }

<#
            }
        }
#>
                #endregion

<#
    }
#>
            }
        }
<#
}
#>
    }
}