<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
//------------------------------------------------------------------------------
// <auto-generated>look at the SpanExtensionsTemplate.tt</auto-generated>
//------------------------------------------------------------------------------
// Copyright (c) Microsoft. All rights reserved. 
// Licensed under the MIT license. See LICENSE file in the project root for full license information. 

namespace System
{
    public static partial class SpanExtensions
    {
<# 
    GenerateSequenceEqualMethod(typeName: "byte", many: "bytes", smallSliceLimit: 512);
    GenerateSequenceEqualMethod(typeName: "char", many: "characters", smallSliceLimit: 512);
    GenerateSequenceEqualMethod(typeName: "short", many: "shorts", smallSliceLimit: 512);
    GenerateSequenceEqualMethod(typeName: "int", many: "integers", smallSliceLimit: 512 / 2);
    GenerateSequenceEqualMethod(typeName: "long", many: "long integers", smallSliceLimit: 512 / 2);

    // spans of floating point numbers must not be compared in bitwise way! 
    // -0 == +0 have different bit representation but the values are equal
#>
    }
}
<#+
    private void GenerateSequenceEqualMethod(string typeName, string many, int smallSliceLimit)
    {#>
        /// <summary>
        /// Determines whether two spans are equal (byte-wise) by comparing the elements by using memcmp
        /// </summary>
        /// <param name="first">A span of <#= many #> to compare to second.</param>
        /// <param name="second">A span of <#= many #> T to compare to first.</param>
        public static bool SequenceEqual(this Span<<#= typeName #>> first, Span<<#= typeName #>> second)
        {
            if (first.Length != second.Length) { return false; }

            // pinvoke calls are expensive (mostly due to memory pinning) so we call memcmp only for big slices
            if (first.Length >= <#= smallSliceLimit #>) { return MemoryUtils.MemCmp(first, second); }

            // for small slices we just use simple loop
            for (int i = 0; i < first.Length; i++) {
                if (first.GetItemWithoutBoundariesCheck(i) != second.GetItemWithoutBoundariesCheck(i)) { 
                    return false; 
                }
            }
            return true;
        }

		/// <summary>
        /// Determines whether two read-only spans are equal (byte-wise) by comparing the elements by using memcmp
        /// </summary>
        /// <param name="first">A span of <#= many #> to compare to second.</param>
        /// <param name="second">A span of <#= many #> T to compare to first.</param>
        public static bool SequenceEqual(this ReadOnlySpan<<#= typeName #>> first, ReadOnlySpan<<#= typeName #>> second)
        {
            if (first.Length != second.Length) { return false; }

            // pinvoke calls are expensive (mostly due to memory pinning) so we call memcmp only for big slices
            if (first.Length >= <#= smallSliceLimit #>) { return MemoryUtils.MemCmp(first, second); }

            // for small slices we just use simple loop
            for (int i = 0; i < first.Length; i++) {
                if (first.GetItemWithoutBoundariesCheck(i) != second.GetItemWithoutBoundariesCheck(i)) { 
                    return false; 
                }
            }
            return true;
        }

<#+}
#>