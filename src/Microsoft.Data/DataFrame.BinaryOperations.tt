<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="ColumnArithmeticTemplate.ttinclude" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// Generated from DataFrameBinaryOperations.tt. Do not modify directly

using System;
using System.Collections.Generic;

namespace Microsoft.Data
{
    public partial class DataFrame
    {
        #region Binary Operations

<# foreach (MethodConfiguration method in methodConfiguration) { #>
<# if (method.MethodType == MethodType.BinaryScalar) { #>
        public DataFrame <#=method.MethodName#><T>(T value, bool inPlace = false)
            where T : unmanaged
<# } #>
<# if (method.MethodType == MethodType.ComparisonScalar) { #>
        public DataFrame <#=method.MethodName#><T>(T value)
            where T : unmanaged
<# } #>
<# if (method.MethodType == MethodType.Binary) {#>
        public DataFrame <#=method.MethodName#><T>(IReadOnlyList<T> values, bool inPlace = false)
            where T : unmanaged
<# } #>
<# if (method.MethodType == MethodType.Comparison) {#>
        public DataFrame <#=method.MethodName#><T>(IReadOnlyList<T> values)
            where T : unmanaged
<# } #>
<# if (method.MethodType == MethodType.BinaryInt ) {#>
        public DataFrame <#=method.MethodName#>(int value, bool inPlace = false)
<# } #>
        {
<# if (method.MethodType == MethodType.BinaryScalar || method.MethodType == MethodType.ComparisonScalar || method.MethodType == MethodType.BinaryInt) {#>
<# } else { #>
            if (values.Count != ColumnCount)
            {
                throw new ArgumentException(Strings.MismatchedColumnLengths, nameof(values));
            }
<# } #>
<# if (method.MethodType == MethodType.BinaryScalar || method.MethodType == MethodType.Binary || method.MethodType == MethodType.BinaryInt) {#>
            DataFrame retDataFrame = inPlace ? this : new DataFrame();
<# } else { #>
            DataFrame retDataFrame = new DataFrame();
<# } #>

<# if (method.MethodType == MethodType.BinaryScalar || method.MethodType == MethodType.Binary || method.MethodType == MethodType.BinaryInt) {#>
            for (int i = 0; i < ColumnCount; i++)
            {
                BaseColumn baseColumn = _table.Column(i);
<# } else { #>
            for (int i = 0; i < ColumnCount; i++)
            {
                BaseColumn baseColumn = _table.Column(i);
<# } #>
<# if (method.MethodType == MethodType.BinaryScalar || method.MethodType == MethodType.BinaryInt) {#>
                BaseColumn newColumn = baseColumn.<#=method.MethodName#>(value, inPlace);
<# } else if (method.MethodType == MethodType.Binary) { #>
                BaseColumn newColumn = baseColumn.<#=method.MethodName#>(values[i], inPlace);
<# } else if (method.MethodType == MethodType.ComparisonScalar) { #>
                BaseColumn newColumn = baseColumn.<#=method.MethodName#>(value);
<# } else { #>
                BaseColumn newColumn = baseColumn.<#=method.MethodName#>(values[i]);
<# } #>
<# if (method.MethodType == MethodType.BinaryScalar || method.MethodType == MethodType.Binary || method.MethodType == MethodType.BinaryInt) {#>
                if (inPlace)
                    retDataFrame.SetColumn(i, newColumn);
                else
                    retDataFrame.InsertColumn(i, newColumn);
<# } else { #>
                retDataFrame.InsertColumn(i, newColumn);
<# } #>
            }
            return retDataFrame;
        }
<# } #>
        #endregion
    }
}
