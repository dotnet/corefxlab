<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="ColumnArithmeticTemplate.ttinclude"#>
<#@ include file="PrimitiveDataFrameColumn.BinaryOperations.Combinations.ttinclude" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// Generated from DataFrameColumn.BinaryOperations.ExplodedColumns.tt. Do not modify directly

using System;
using System.Collections.Generic;

namespace Microsoft.Data.Analysis
{
    public static class BinaryOperations
    {
<# 
bool supportedInPlace(string type1, string type2)
{
    primitiveTypeToPrimitivityLevelMap.TryGetValue(type1, out int columnTypeLevel);
    primitiveTypeToPrimitivityLevelMap.TryGetValue(type2, out int otherColumnTypeLevel);
    if (columnTypeLevel < otherColumnTypeLevel)
    {
        return false;
    }
    return true;
}
#>
<# 
void GenerateAllBinaryCombinationsForMethod(string methodName)
{
 foreach (List<string> types in BinaryOperationCombinations.binaryOperationCombinations) 
{ 
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
    string fullOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
#>
<#
    if (supportedInPlace(columnType, otherColumnType))
    {
#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullColumnType#> <#=columnType#>Column, <#=fullOtherColumnType#> column, bool inPlace = false)
<#
    }
    else
    {
#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullColumnType#> <#=columnType#>Column, <#=fullOtherColumnType#> column)
<#
    }
#>
        {
<#
    if (columnType == otherColumnType)
    {
#>
            return (<#=fullReturnType#>)<#=columnType#>Column.<#=methodName#>Column(column, inPlace);
<#
    }
    else
    {
        primitiveTypeToPrimitivityLevelMap.TryGetValue(columnType, out int columnTypeLevel);
        primitiveTypeToPrimitivityLevelMap.TryGetValue(otherColumnType, out int otherColumnTypeLevel);
        if (otherColumnTypeLevel > columnTypeLevel)
        {
#>
            <#=fullReturnType#> <#=returnType#>Column = <#=columnType#>Column.CloneAs<#=capitalizedReturnType#>Column();
            return (<#=fullReturnType#>)<#=returnType#>Column.<#=methodName#>Column(column, inPlace: true);
<#
        }
        else
        {
#>
            <#=fullReturnType#> other<#=returnType#>Column = column.CloneAs<#=capitalizedReturnType#>Column();
            return (<#=fullReturnType#>)<#=returnType#>Column.<#=methodName#>Column(other<#=returnType#>Column, inPlace);
<#
        }
#>
<#
    }
#>
        }
<# 
} 
}
#>
<# 
void GenerateAllBinaryScalarCombinationsForMethod(string methodName)
{
 foreach (List<string> types in BinaryOperationCombinations.binaryOperationCombinations) 
{ 
    string returnType = types[2];
    string columnType = types[0];
    string valueType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);

#>
<#
    if (supportedInPlace(columnType, valueType))
    {
#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullColumnType#> <#=columnType#>Column, <#=valueType#> value, bool inPlace = false)
<#
    }
    else
    {
#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullColumnType#> <#=columnType#>Column, <#=valueType#> value)
<#
    }
#>
        {
<#
    if (columnType == valueType)
    {
#>
            return (<#=fullReturnType#>)<#=columnType#>Column.<#=methodName#>Value(value, inPlace);
<#
    }
    else
    {
        primitiveTypeToPrimitivityLevelMap.TryGetValue(columnType, out int columnTypeLevel);
        primitiveTypeToPrimitivityLevelMap.TryGetValue(valueType, out int valueTypeLevel);
        if (valueTypeLevel > columnTypeLevel)
        {
#>
            <#=fullReturnType#> <#=returnType#>Column = <#=columnType#>Column.CloneAs<#=capitalizedReturnType#>Column();
            return (<#=fullReturnType#>)<#=returnType#>Column.<#=methodName#>Value(value, inPlace: true);
<#
        }
        else
        {
#>
            <#=returnType#> convertedValue = (<#=returnType#>)value;
            return (<#=fullReturnType#>)<#=returnType#>Column.<#=methodName#>Value(convertedValue, inPlace);
<#
        }
#>
<#
    }
#>
        }
<# 
} 
}
#>
<#
void GenerateAllBinaryBitwiseOperationsForMethod(string methodName)
{
#>
        public static BoolDataFrameColumn <#=methodName#>(this BoolDataFrameColumn boolColumn, BoolDataFrameColumn column, bool inPlace = false)
        {
            return (BoolDataFrameColumn)boolColumn.<#=methodName#>Column(column, inPlace);
        }
<#
}
#>
<#
void GenerateAllBinaryScalarBitwiseOperationsForMethod(string methodName)
{
#>
        public static BoolDataFrameColumn <#=methodName#>(this BoolDataFrameColumn boolColumn, bool value, bool inPlace = false)
        {
            return (BoolDataFrameColumn)boolColumn.<#=methodName#>Value(value, inPlace);
        }
<#
}
#>
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    // Don't generate method for Comparison and ComparisonScalar methods here
    if (method.MethodType == MethodType.Binary && method.IsNumeric)
    {
        GenerateAllBinaryCombinationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.BinaryScalar && method.IsNumeric)
    {
        GenerateAllBinaryScalarCombinationsForMethod(method.MethodName);
        GenerateAllBinaryScalarCombinationsForMethod("Reverse" + method.MethodName);
    }
    else if (method.MethodType == MethodType.Binary && method.IsBitwise)
    {
        GenerateAllBinaryBitwiseOperationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.BinaryScalar && method.IsBitwise)
    {
        GenerateAllBinaryScalarBitwiseOperationsForMethod(method.MethodName);
    }
}
#>
    }
<# 
void GenerateAllComparisonCombinationsForMethod(string methodName)
{
 foreach (List<string> types in ComparisonOperationCombinations.comparisonOperationCombinations) 
 {
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
    string fullOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);

#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullColumnType#> <#=columnType#>Column, <#=fullOtherColumnType#> column)
        {
            return (<#=fullReturnType#>)<#=columnType#>Column.<#=methodName#>Column(column);
        }
<# 
 }
 }
#>

<# 
void GenerateAllComparisonScalarCombinationsForMethod(string methodName)
{
 foreach (List<string> types in ComparisonOperationCombinations.comparisonOperationCombinations) 
 {
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullColumnType#> <#=columnType#>Column, <#=otherColumnType#> value)
        {
            return (<#=fullReturnType#>)<#=columnType#>Column.<#=methodName#>Value(value);
        }
<# 
 }
}
#>
    public static class ComparisonOperations
    {
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    if (method.MethodType == MethodType.Comparison)
    {
        GenerateAllComparisonCombinationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.ComparisonScalar)
    {
        GenerateAllComparisonScalarCombinationsForMethod(method.MethodName);
    }
}
#>
    }

<#
void GenerateAllBinaryShiftCombinationsForMethod(string methodName)
{
    foreach (var type in typeConfiguration)
    {
        if (!type.SupportsNumeric || !type.SupportsBitwise)
        {
            continue;
        }
        
        string returnType = type.TypeName;
        string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
#>
        public static <#=fullReturnType#> <#=methodName#>(this <#=fullReturnType#> column, int value, bool inPlace = false)
        {
            return (<#=fullReturnType#>)column.<#=methodName#>Value(value, inPlace);
        }
<#
    }
}
#>
    public static class BinaryShiftOperations
    {
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    if (method.MethodType == MethodType.BinaryInt)
    {
        GenerateAllBinaryShiftCombinationsForMethod(method.MethodName);
    }
}
#>
    }
}
