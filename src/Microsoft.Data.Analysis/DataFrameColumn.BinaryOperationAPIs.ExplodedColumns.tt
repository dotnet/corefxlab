<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ output extension=".cs" #>
<#@ include file="ColumnArithmeticTemplate.ttinclude"#>
<#@ include file="PrimitiveDataFrameColumn.BinaryOperations.Combinations.ttinclude" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// Generated from DataFrameColumn.BinaryOperationAPIs.ExplodedColumns.tt. Do not modify directly

using System;
using System.Collections.Generic;

namespace Microsoft.Data.Analysis
{
<# 
bool supportedInPlace(string type1, string type2)
{
    primitiveTypeToPrimitivityLevelMap.TryGetValue(type1, out int columnTypeLevel);
    primitiveTypeToPrimitivityLevelMap.TryGetValue(type2, out int otherColumnTypeLevel);
    if (columnTypeLevel < otherColumnTypeLevel)
    {
        return false;
    }
    return true;
}
#>
<# 
void GenerateAllBinaryCombinationsForMethod(string methodName)
{
 foreach (List<string> types in BinaryOperationCombinations.binaryOperationCombinations) 
{ 
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
    string fullOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
#>
    public partial class <#=fullColumnType#>
    {
<#
    if (supportedInPlace(columnType, otherColumnType))
    {
#>
        public <#=fullReturnType#> <#=methodName#>(<#=fullOtherColumnType#> column, bool inPlace = false)
<#
    }
    else
    {
#>
        public <#=fullReturnType#> <#=methodName#>(<#=fullOtherColumnType#> column)
<#
    }
#>
        {
<#
    if (columnType == otherColumnType)
    {
#>
            return <#=methodName#>Implementation(column, inPlace);
<#
    }
    else
    {
        primitiveTypeToPrimitivityLevelMap.TryGetValue(columnType, out int columnTypeLevel);
        primitiveTypeToPrimitivityLevelMap.TryGetValue(otherColumnType, out int otherColumnTypeLevel);
        if (otherColumnTypeLevel > columnTypeLevel)
        {
#>
            <#=fullReturnType#> <#=returnType#>Column = CloneAs<#=capitalizedReturnType#>Column();
            return <#=returnType#>Column.<#=methodName#>Implementation(column, inPlace: true);
<#
        }
        else
        {
#>
            <#=fullReturnType#> other<#=returnType#>Column = column.CloneAs<#=capitalizedReturnType#>Column();
            return <#=methodName#>Implementation(other<#=returnType#>Column, inPlace);
<#
        }
#>
<#
    }
#>
        }
    }
<# 
} 
}
#>
<# 
void GenerateAllBinaryScalarCombinationsForMethod(string methodName)
{
 foreach (List<string> types in BinaryOperationCombinations.binaryOperationCombinations) 
{ 
    string returnType = types[2];
    string columnType = types[0];
    string valueType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);

#>
    public partial class <#=fullColumnType#>
    {
<#
    if (supportedInPlace(columnType, valueType))
    {
#>
        public <#=fullReturnType#> <#=methodName#>(<#=valueType#> value, bool inPlace = false)
<#
    }
    else
    {
#>
        public <#=fullReturnType#> <#=methodName#>(<#=valueType#> value)
<#
    }
#>
        {
<#
    if (columnType == valueType)
    {
#>
            return <#=methodName#>Implementation(value, inPlace);
<#
    }
    else
    {
        primitiveTypeToPrimitivityLevelMap.TryGetValue(columnType, out int columnTypeLevel);
        primitiveTypeToPrimitivityLevelMap.TryGetValue(valueType, out int valueTypeLevel);
        if (valueTypeLevel > columnTypeLevel)
        {
#>
            <#=fullReturnType#> <#=returnType#>Column = CloneAs<#=capitalizedReturnType#>Column();
            return <#=returnType#>Column.<#=methodName#>Implementation(value, inPlace: true);
<#
        }
        else
        {
#>
            <#=returnType#> convertedValue = (<#=returnType#>)value;
            return <#=methodName#>Implementation(convertedValue, inPlace);
<#
        }
#>
<#
    }
#>
        }
    }
<# 
} 
}
#>
<#
void GenerateAllBinaryBitwiseOperationsForMethod(string methodName)
{
#>
    public partial class BoolDataFrameColumn
    {
        public BoolDataFrameColumn <#=methodName#>(BoolDataFrameColumn column, bool inPlace = false)
        {
            if (column.Length != Length)
            {
                throw new ArgumentException(Strings.MismatchedColumnLengths, nameof(column));
            }
            BoolDataFrameColumn retColumn = inPlace ? this : CloneAsBoolColumn();
            retColumn._columnContainer.And(column._columnContainer);
            return retColumn;
        }
    }
<#
}
#>
<#
void GenerateAllBinaryScalarBitwiseOperationsForMethod(string methodName)
{
#>
    public partial class BoolDataFrameColumn
    {
        public new BoolDataFrameColumn <#=methodName#>(bool value, bool inPlace = false)
        {
            BoolDataFrameColumn retColumn = inPlace ? this : CloneAsBoolColumn();
            retColumn._columnContainer.And(value);
            return retColumn;
        }
    }
<#
}
#>
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    // Don't generate method for Comparison and ComparisonScalar methods here
    if (method.MethodType == MethodType.Binary && method.IsNumeric)
    {
        GenerateAllBinaryCombinationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.BinaryScalar && method.IsNumeric)
    {
        GenerateAllBinaryScalarCombinationsForMethod(method.MethodName);
        GenerateAllBinaryScalarCombinationsForMethod("Reverse" + method.MethodName);
    }
    else if (method.MethodType == MethodType.Binary && method.IsBitwise)
    {
        GenerateAllBinaryBitwiseOperationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.BinaryScalar && method.IsBitwise)
    {
        GenerateAllBinaryScalarBitwiseOperationsForMethod(method.MethodName);
    }
}
#>
<# 
void GenerateAllComparisonCombinationsForMethod(string methodName)
{
 foreach (List<string> types in ComparisonOperationCombinations.comparisonOperationCombinations) 
 {
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
    string fullOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
    string capitalizedOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType);
    string capitalizedColumnType = GetCapitalizedPrimitiveTypes(columnType);

#>
    public partial class <#=fullColumnType#>
    {
        public <#=fullReturnType#> <#=methodName#>(<#=fullOtherColumnType#> column)
        {
<#
    if (columnType == otherColumnType)
    {
#>
            return <#=methodName#>Implementation(column);
<#
    }
    else
    {
        primitiveTypeToPrimitivityLevelMap.TryGetValue(columnType, out int columnTypeLevel);
        primitiveTypeToPrimitivityLevelMap.TryGetValue(otherColumnType, out int otherColumnTypeLevel);
        if (otherColumnTypeLevel > columnTypeLevel)
        {
#>
            <#=fullOtherColumnType#> <#=otherColumnType#>Column = CloneAs<#=capitalizedOtherColumnType#>Column();
            return <#=otherColumnType#>Column.<#=methodName#>Implementation(column);
<#
        }
        else
        {
#>
            <#=fullColumnType#> other<#=columnType#>Column = column.CloneAs<#=capitalizedColumnType#>Column();
            return <#=methodName#>Implementation(other<#=columnType#>Column);
<#
        }
#>
<#
    }
#>
        }
    }
<# 
 }
 }
#>

<# 
void GenerateAllComparisonScalarCombinationsForMethod(string methodName)
{
 foreach (List<string> types in ComparisonOperationCombinations.comparisonOperationCombinations) 
 {
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
    string fullOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
    string capitalizedOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType);
    string capitalizedColumnType = GetCapitalizedPrimitiveTypes(columnType);
#>
    public partial class <#=fullColumnType#>
    {
        public <#=fullReturnType#> <#=methodName#>(<#=otherColumnType#> value)
        {
<#
    if (columnType == otherColumnType)
    {
#>
            return <#=methodName#>Implementation(value);
<#
    }
    else
    {
        primitiveTypeToPrimitivityLevelMap.TryGetValue(columnType, out int columnTypeLevel);
        primitiveTypeToPrimitivityLevelMap.TryGetValue(otherColumnType, out int otherColumnTypeLevel);
        if (otherColumnTypeLevel > columnTypeLevel)
        {
#>
            <#=fullOtherColumnType#> <#=otherColumnType#>Column = CloneAs<#=capitalizedOtherColumnType#>Column();
            return <#=otherColumnType#>Column.<#=methodName#>Implementation(value);
<#
        }
        else
        {
#>
            <#=columnType#> other<#=columnType#>Value = (<#=columnType#>)value;
            return <#=methodName#>Implementation(other<#=columnType#>Value);
<#
        }
#>
<#
    }
#>
        }
    }
<# 
 }
}
#>
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    if (method.MethodType == MethodType.Comparison)
    {
        GenerateAllComparisonCombinationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.ComparisonScalar)
    {
        GenerateAllComparisonScalarCombinationsForMethod(method.MethodName);
    }
}
#>

<#
void GenerateAllBinaryShiftCombinationsForMethod(string methodName)
{
    foreach (var type in typeConfiguration)
    {
        if (!type.SupportsNumeric || !type.SupportsBitwise)
        {
            continue;
        }
        
        string returnType = type.TypeName;
        string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
#>
    public partial class <#=fullReturnType#>
    {
        public new <#=fullReturnType#> <#=methodName#>(int value, bool inPlace = false)
        {
            var result = (PrimitiveDataFrameColumn<<#=returnType#>>)base.<#=methodName#>(value, inPlace);
            return new <#=fullReturnType#>(result);
        }
    }
<#
    }
}
#>
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    if (method.MethodType == MethodType.BinaryInt)
    {
        GenerateAllBinaryShiftCombinationsForMethod(method.MethodName);
    }
}
#>
}
