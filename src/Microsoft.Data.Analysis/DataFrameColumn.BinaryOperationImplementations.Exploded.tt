<#@ template debug="false" hostspecific="false" language="C#" #>
<#@ assembly name="System.Core" #>
<#@ import namespace="System.Linq" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Diagnostics" #>
<#@ output extension=".cs" #>
<#@ include file="ColumnArithmeticTemplate.ttinclude"#>
<#@ include file="PrimitiveDataFrameColumn.BinaryOperations.Combinations.ttinclude" #>
// Licensed to the .NET Foundation under one or more agreements.
// The .NET Foundation licenses this file to you under the MIT license.
// See the LICENSE file in the project root for more information.

// Generated from DataFrameColumn.BinaryOperationImplementations.ExplodedColumns.tt. Do not modify directly

using System;
using System.Collections.Generic;

namespace Microsoft.Data.Analysis
{
<# 
bool supportedInPlace(string type1, string type2)
{
    primitiveTypeToPrimitivityLevelMap.TryGetValue(type1, out int columnTypeLevel);
    primitiveTypeToPrimitivityLevelMap.TryGetValue(type2, out int otherColumnTypeLevel);
    if (columnTypeLevel < otherColumnTypeLevel)
    {
        return false;
    }
    return true;
}
#>
<# 
// This method generates implementations where the arguments are of the same type.
void GenerateAllBinaryCombinationsForMethod(string inputMethodName)
{
 foreach (List<string> types in BinaryOperationCombinations.binaryOperationCombinations) 
{ 
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];
    if (columnType != otherColumnType)
    {
        continue;
    }
    Debug.Assert(returnType == otherColumnType);

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = fullColumnType;
    string fullOtherColumnType = fullColumnType;

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
    string methodName = inputMethodName + "Implementation";
#>
    public partial class <#=fullColumnType#>
    {
<#
    if (supportedInPlace(columnType, otherColumnType))
    {
#>
        internal <#=fullReturnType#> <#=methodName#>(<#=fullOtherColumnType#> column, bool inPlace = false)
<#
    }
    else
    {
#>
        internal <#=fullReturnType#> <#=methodName#>(<#=fullOtherColumnType#> column)
<#
    }
#>
        {
            if (column.Length != Length)
            {
                throw new ArgumentException(Strings.MismatchedColumnLengths, nameof(column));
            }
            <#=fullReturnType#> newColumn = inPlace ? this : CloneAs<#=capitalizedReturnType#>Column();
            newColumn._columnContainer.<#=inputMethodName#>(column._columnContainer);
            return newColumn;
        }
    }
<# 
} 
}
#>
<# 
// This method generates implementations where the arguments are of the same type.
void GenerateAllBinaryScalarCombinationsForMethod(string inputMethodName)
{
 foreach (List<string> types in BinaryOperationCombinations.binaryOperationCombinations) 
{ 
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];
    if (columnType != otherColumnType)
    {
        continue;
    }
    Debug.Assert(returnType == otherColumnType);

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = fullColumnType;
    string fullOtherColumnType = fullColumnType;

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
    string methodName = inputMethodName;
    methodName += "Implementation";
#>
    public partial class <#=fullColumnType#>
    {
<#
    if (supportedInPlace(columnType, otherColumnType))
    {
#>
        internal <#=fullReturnType#> <#=methodName#>(<#=otherColumnType#> value, bool inPlace = false)
<#
    }
    else
    {
#>
        internal <#=fullReturnType#> <#=methodName#>(<#=otherColumnType#> value)
<#
    }
#>
        {
            <#=fullReturnType#> newColumn = inPlace ? this : CloneAs<#=capitalizedReturnType#>Column();
            newColumn._columnContainer.<#=inputMethodName#>(value);
            return newColumn;
        }
    }
<# 
} 
}
#>
<# 
void GenerateAllComparisonCombinationsForMethod(string inputMethodName)
{
 foreach (List<string> types in ComparisonOperationCombinations.comparisonOperationCombinations) 
 {
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];
    if (columnType != otherColumnType)
    {
        continue;
    }
    Debug.Assert(returnType == otherColumnType);

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";
    string fullOtherColumnType = GetCapitalizedPrimitiveTypes(otherColumnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
    string methodName = inputMethodName;
    methodName += "Implementation";

#>
    public partial class <#=fullColumnType#>
    {
        public <#=fullReturnType#> <#=methodName#>(<#=fullOtherColumnType#> column)
        {
            BoolDataFrameColumn newColumn = CloneAsBoolColumn();
            _columnContainer.<#=inputMethodName#>(column._columnContainer, newColumn._columnContainer);
            return newColumn;
        }
    }
<# 
 }
 }
#>
<# 
void GenerateAllComparisonScalarCombinationsForMethod(string inputMethodName)
{
 foreach (List<string> types in ComparisonOperationCombinations.comparisonOperationCombinations) 
 {
    string returnType = types[2];
    string columnType = types[0];
    string otherColumnType = types[1];
    if (columnType != otherColumnType)
    {
        continue;
    }
    Debug.Assert(returnType == otherColumnType);

    string fullColumnType = GetCapitalizedPrimitiveTypes(columnType) + "DataFrameColumn";
    string fullReturnType = GetCapitalizedPrimitiveTypes(returnType) + "DataFrameColumn";

    string capitalizedReturnType = GetCapitalizedPrimitiveTypes(returnType);
    string methodName = inputMethodName;
    methodName += "Implementation";

#>
    public partial class <#=fullColumnType#>
    {
        public <#=fullReturnType#> <#=methodName#>(<#=otherColumnType#> value)
        {
            BoolDataFrameColumn newColumn = CloneAsBoolColumn();
            _columnContainer.<#=inputMethodName#>(value, newColumn._columnContainer);
            return newColumn;
        }
    }
<# 
 }
 }
#>
<#
foreach (MethodConfiguration method in methodConfiguration)
{
    // Don't generate method for Comparison and ComparisonScalar methods here
    if (method.MethodType == MethodType.Binary && method.IsNumeric)
    {
        GenerateAllBinaryCombinationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.BinaryScalar && method.IsNumeric)
    {
        GenerateAllBinaryScalarCombinationsForMethod(method.MethodName);
        GenerateAllBinaryScalarCombinationsForMethod("Reverse" + method.MethodName);
    }
    else if (method.MethodType == MethodType.Comparison)
    {
        GenerateAllComparisonCombinationsForMethod(method.MethodName);
    }
    else if (method.MethodType == MethodType.ComparisonScalar)
    {
        GenerateAllComparisonScalarCombinationsForMethod(method.MethodName);
    }
}
#>
}
