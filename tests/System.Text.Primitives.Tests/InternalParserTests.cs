// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in ParserTests.tt.

using System.Runtime.InteropServices;
using System.Text;
using System.Text.Utf8;
using Xunit;

namespace System.Text.Primitives.Tests
{
	public partial class InternalParserTests
    {
	    static Tuple<byte, int>[] s_utf8ParsingTrie = new Tuple<byte, int>[] {
            Tuple.Create((byte)17, 0x3004390D),
            Tuple.Create((byte)43, 18),
            Tuple.Create((byte)45, 19),
            Tuple.Create((byte)46, 20),
            Tuple.Create((byte)48, 21),
            Tuple.Create((byte)49, 22),
            Tuple.Create((byte)50, 23),
            Tuple.Create((byte)51, 24),
            Tuple.Create((byte)52, 25),
            Tuple.Create((byte)53, 26),
            Tuple.Create((byte)54, 27),
            Tuple.Create((byte)55, 28),
            Tuple.Create((byte)56, 29),
            Tuple.Create((byte)57, 30),
            Tuple.Create((byte)69, 31),
            Tuple.Create((byte)73, 32),
            Tuple.Create((byte)78, 33),
            Tuple.Create((byte)101, 34),
            Tuple.Create((byte)0, 14),
            Tuple.Create((byte)0, 13),
            Tuple.Create((byte)0, 10),
            Tuple.Create((byte)0, 0),
            Tuple.Create((byte)0, 1),
            Tuple.Create((byte)0, 2),
            Tuple.Create((byte)0, 3),
            Tuple.Create((byte)0, 4),
            Tuple.Create((byte)0, 5),
            Tuple.Create((byte)0, 6),
            Tuple.Create((byte)0, 7),
            Tuple.Create((byte)0, 8),
            Tuple.Create((byte)0, 9),
            Tuple.Create((byte)0, 16),
            Tuple.Create((byte)0, 12),
            Tuple.Create((byte)0, 15),
            Tuple.Create((byte)0, 16),
        };

        static Tuple<byte, int>[] s_thais_utf8ParsingTrie = new Tuple<byte, int>[] {
            Tuple.Create((byte)4, 0),
            Tuple.Create((byte)43, 5),
            Tuple.Create((byte)69, 6),
            Tuple.Create((byte)101, 7),
            Tuple.Create((byte)0xE0, 8),
            Tuple.Create((byte)0, 14),
            Tuple.Create((byte)0, 16),
            Tuple.Create((byte)0, 16),
            Tuple.Create((byte)2, 0),
            Tuple.Create((byte)0xB8, 11),
            Tuple.Create((byte)0xB9, 15),
            Tuple.Create((byte)3, 0),
            Tuple.Create((byte)0x88, 27),
            Tuple.Create((byte)0xA5, 28),
            Tuple.Create((byte)0xAA, 29),
            Tuple.Create((byte)11, -1878877941 /* 0x9002990B */),
            Tuple.Create((byte)0x84, 30),
            Tuple.Create((byte)0x90, 31),
            Tuple.Create((byte)0x91, 32),
            Tuple.Create((byte)0x92, 33),
            Tuple.Create((byte)0x93, 34),
            Tuple.Create((byte)0x94, 35),
            Tuple.Create((byte)0x95, 36),
            Tuple.Create((byte)0x96, 37),
            Tuple.Create((byte)0x97, 38),
            Tuple.Create((byte)0x98, 39),
            Tuple.Create((byte)0x99, 40),
            Tuple.Create((byte)0, 10),
            Tuple.Create((byte)0, 13),
            Tuple.Create((byte)0, 12),
            Tuple.Create((byte)0, 15),
            Tuple.Create((byte)0, 0),
            Tuple.Create((byte)0, 1),
            Tuple.Create((byte)0, 2),
            Tuple.Create((byte)0, 3),
            Tuple.Create((byte)0, 4),
            Tuple.Create((byte)0, 5),
            Tuple.Create((byte)0, 6),
            Tuple.Create((byte)0, 7),
            Tuple.Create((byte)0, 8),
            Tuple.Create((byte)0, 9),
        };

		static byte[][] s_utf8digitsAndSymbols = new byte[][] {
            new byte[] { 48, },
            new byte[] { 49, },
            new byte[] { 50, },
            new byte[] { 51, },
            new byte[] { 52, },
            new byte[] { 53, },
            new byte[] { 54, },
            new byte[] { 55, },
            new byte[] { 56, },
            new byte[] { 57, }, // digit 9
            new byte[] { 46, }, // decimal separator
            null, // so that it is != to uft8DigitsAndSymbols
            new byte[] { 73, 110, 102, 105, 110, 105, 116, 121, },
            new byte[] { 45, }, // minus sign
            new byte[] { 43, }, // plus sign
            new byte[] { 78, 97, 78, }, // NaN
            new byte[] { 69, }, // E
        };

		static byte[][] s_thaiUtf8DigitsAndSymbols = new byte[][]
        {
            new byte[] { 0xe0, 0xb9, 0x90 }, new byte[] { 0xe0, 0xb9, 0x91 }, new byte[] { 0xe0, 0xb9, 0x92 },
            new byte[] { 0xe0, 0xb9, 0x93 }, new byte[] { 0xe0, 0xb9, 0x94 }, new byte[] { 0xe0, 0xb9, 0x95 }, new byte[] { 0xe0, 0xb9, 0x96 },
            new byte[] { 0xe0, 0xb9, 0x97 }, new byte[] { 0xe0, 0xb9, 0x98 }, new byte[] { 0xe0, 0xb9, 0x99 }, new byte[] { 0xE0, 0xB8, 0x88, 0xE0, 0xB8, 0x94 }, null,
            new byte[] { 0xE0, 0xB8, 0xAA, 0xE0, 0xB8, 0xB4, 0xE0, 0xB9, 0x88, 0xE0, 0xB8, 0x87, 0xE0, 0xB8, 0x97, 0xE0, 0xB8, 0xB5, 0xE0, 0xB9, 0x88, 0xE0, 0xB9, 0x83,
                0xE0, 0xB8, 0xAB, 0xE0, 0xB8, 0x8D, 0xE0, 0xB9, 0x88, 0xE0, 0xB9, 0x82, 0xE0, 0xB8, 0x95, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0xAB, 0xE0, 0xB8, 0xA5, 0xE0,
                0xB8, 0xB7, 0xE0, 0xB8, 0xAD, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0x81, 0xE0, 0xB8, 0xB4, 0xE0, 0xB8, 0x99 },
            new byte[] { 0xE0, 0xB8, 0xA5, 0xE0, 0xB8, 0x9A }, new byte[] { 43 }, new byte[] { 0xE0, 0xB9, 0x84, 0xE0, 0xB8, 0xA1, 0xE0, 0xB9, 0x88, 0xE0, 0xB9,
                0x83, 0xE0, 0xB8, 0x8A, 0xE0, 0xB9, 0x88, 0xE0, 0xB8, 0x95, 0xE0, 0xB8, 0xB1, 0xE0, 0xB8, 0xA7, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0xA5, 0xE0, 0xB8, 0x82 },
            new byte[] { 69 }, new byte[] { 101 },
        };
            
        static EncodingData s_thaiEncoding = new EncodingData(s_thaiUtf8DigitsAndSymbols, TextEncoder.Utf8, s_thais_utf8ParsingTrie);

		static EncodingData s_utf8Encoding = new EncodingData(s_utf8digitsAndSymbols, TextEncoder.Utf8, s_utf8ParsingTrie);

        private byte[] UtfEncode(string s, bool utf16)
        {
            if (utf16)
                return Encoding.Unicode.GetBytes(s);
            else
                return Encoding.UTF8.GetBytes(s);
        }

		#region byte

		// [Theory]
        [InlineData("55", true, 0, 55, 2)]
        [InlineData("blahblahh68", true, 9, 68, 2)]
        [InlineData("68abhced", true, 0, 68, 2)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("255", true, 0, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseCustomCultureByteArrayToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseByte(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("55", true, 0, 55, 2)]
        [InlineData("blahblahh68", true, 9, 68, 2)]
        [InlineData("68abhced", true, 0, 68, 2)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("255", true, 0, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteArrayToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseByte(UtfEncode(text, false), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("55", true, 0, 55, 2)]
        [InlineData("blahblahh68", true, 9, 68, 2)]
        [InlineData("68abhced", true, 0, 68, 2)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("255", true, 0, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseByte(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("55", true, 0, 55, 2)]
        [InlineData("blahblahh68", true, 9, 68, 2)]
        [InlineData("68abhced", true, 0, 68, 2)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("255", true, 0, 255, 3)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            EncodingData fd = EncodingData.InvariantUtf8;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseByte(arrayPointer, index, textBytes.Length, 'R', fd,  out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("55", true, 0, 55, 4)]
        [InlineData("blahblahh68", true, 18, 68, 4)]
        [InlineData("68abhced", true, 0, 68, 4)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("255", true, 0, 255, 6)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteArrayToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseByte(UtfEncode(text, true), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("55", true, 0, 55, 4)]
        [InlineData("blahblahh68", true, 18, 68, 4)]
        [InlineData("68abhced", true, 0, 68, 4)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("255", true, 0, 255, 6)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseByte(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("55", true, 0, 55, 4)]
        [InlineData("blahblahh68", true, 18, 68, 4)]
        [InlineData("68abhced", true, 0, 68, 4)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("255", true, 0, 255, 6)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("256", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToByte(string text, bool expectSuccess, int index, byte expectedValue, int expectedBytesConsumed)
        {
            byte parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            EncodingData fd = EncodingData.InvariantUtf16;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseByte(arrayPointer, index, textBytes.Length, 'R', fd,  out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region ushort

		// [Theory]
        [InlineData("5535", true, 0, 5535, 4)]
        [InlineData("blahblahh6836", true, 9, 6836, 4)]
        [InlineData("6836abhced", true, 0, 6836, 4)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("65535", true, 0, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseCustomCultureByteArrayToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseUInt16(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("5535", true, 0, 5535, 4)]
        [InlineData("blahblahh6836", true, 9, 6836, 4)]
        [InlineData("6836abhced", true, 0, 6836, 4)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("65535", true, 0, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteArrayToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseUInt16(UtfEncode(text, false), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("5535", true, 0, 5535, 4)]
        [InlineData("blahblahh6836", true, 9, 6836, 4)]
        [InlineData("6836abhced", true, 0, 6836, 4)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("65535", true, 0, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseUInt16(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("5535", true, 0, 5535, 4)]
        [InlineData("blahblahh6836", true, 9, 6836, 4)]
        [InlineData("6836abhced", true, 0, 6836, 4)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("65535", true, 0, 65535, 5)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            EncodingData fd = EncodingData.InvariantUtf8;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUInt16(arrayPointer, index, textBytes.Length, 'R', fd, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("5535", true, 0, 5535, 8)]
        [InlineData("blahblahh6836", true, 18, 6836, 8)]
        [InlineData("6836abhced", true, 0, 6836, 8)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("65535", true, 0, 65535, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteArrayToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseUInt16(UtfEncode(text, true), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("5535", true, 0, 5535, 8)]
        [InlineData("blahblahh6836", true, 18, 6836, 8)]
        [InlineData("6836abhced", true, 0, 6836, 8)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("65535", true, 0, 65535, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseUInt16(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("5535", true, 0, 5535, 8)]
        [InlineData("blahblahh6836", true, 18, 6836, 8)]
        [InlineData("6836abhced", true, 0, 6836, 8)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("65535", true, 0, 65535, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("65536", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUshort(string text, bool expectSuccess, int index, ushort expectedValue, int expectedBytesConsumed)
        {
            ushort parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            EncodingData fd = EncodingData.InvariantUtf16;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUInt16(arrayPointer, index, textBytes.Length, 'R', fd, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region uint

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 9)]
        [InlineData("blahblahh354864498", true, 9, 354864498, 9)]
        [InlineData("354864498abhced", true, 0, 354864498, 9)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseCustomCultureByteArrayToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseUInt32(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 9)]
        [InlineData("blahblahh354864498", true, 9, 354864498, 9)]
        [InlineData("354864498abhced", true, 0, 354864498, 9)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteArrayToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseUInt32(UtfEncode(text, false), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 9)]
        [InlineData("blahblahh354864498", true, 9, 354864498, 9)]
        [InlineData("354864498abhced", true, 0, 354864498, 9)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseUInt32(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 9)]
        [InlineData("blahblahh354864498", true, 9, 354864498, 9)]
        [InlineData("354864498abhced", true, 0, 354864498, 9)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 10)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            EncodingData fd = EncodingData.InvariantUtf8;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUInt32(arrayPointer, index, textBytes.Length, 'R', fd, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 18)]
        [InlineData("blahblahh354864498", true, 18, 354864498, 18)]
        [InlineData("354864498abhced", true, 0, 354864498, 18)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteArrayToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseUInt32(UtfEncode(text, true), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 18)]
        [InlineData("blahblahh354864498", true, 18, 354864498, 18)]
        [InlineData("354864498abhced", true, 0, 354864498, 18)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseUInt32(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("294967295", true, 0, 294967295, 18)]
        [InlineData("blahblahh354864498", true, 18, 354864498, 18)]
        [InlineData("354864498abhced", true, 0, 354864498, 18)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("4294967295", true, 0, 4294967295, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("4294967296", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUint(string text, bool expectSuccess, int index, uint expectedValue, int expectedBytesConsumed)
        {
            uint parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            EncodingData fd = EncodingData.InvariantUtf16;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUInt32(arrayPointer, index, textBytes.Length, 'R', fd, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region ulong

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 19)]
        [InlineData("blahblahh6745766045317562215", true, 9, 6745766045317562215, 19)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseCustomCultureByteArrayToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseUInt64(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 19)]
        [InlineData("blahblahh6745766045317562215", true, 9, 6745766045317562215, 19)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteArrayToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseUInt64(UtfEncode(text, false), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 19)]
        [InlineData("blahblahh6745766045317562215", true, 9, 6745766045317562215, 19)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8SpanToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseUInt64(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 19)]
        [InlineData("blahblahh6745766045317562215", true, 9, 6745766045317562215, 19)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 19)]
        [InlineData("0", true, 0, 0, 1)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 20)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            EncodingData fd = EncodingData.InvariantUtf8;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUInt64(arrayPointer, index, textBytes.Length, 'R', fd, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 38)]
        [InlineData("blahblahh6745766045317562215", true, 18, 6745766045317562215, 38)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 38)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 40)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteArrayToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseUInt64(UtfEncode(text, true), index, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 38)]
        [InlineData("blahblahh6745766045317562215", true, 18, 6745766045317562215, 38)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 38)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 40)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16SpanToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseUInt64(span, 'R', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("8446744073709551615", true, 0, 8446744073709551615, 38)]
        [InlineData("blahblahh6745766045317562215", true, 18, 6745766045317562215, 38)]
        [InlineData("6745766045317562215abhced", true, 0, 6745766045317562215, 38)]
        [InlineData("0", true, 0, 0, 2)] // min value
        [InlineData("18446744073709551615", true, 0, 18446744073709551615, 40)] // max value
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("18446744073709551616", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf16ByteStarToUlong(string text, bool expectSuccess, int index, ulong expectedValue, int expectedBytesConsumed)
        {
            ulong parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, true);
            EncodingData fd = EncodingData.InvariantUtf16;
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUInt64(arrayPointer, index, textBytes.Length, 'R', fd, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region sbyte

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh27", true, 9, 27, 2)]
        [InlineData("53abcdefg", true, 0, 53, 2)]
        [InlineData("The smallest of this type is -128.", true, 29, -128, 4)]
        [InlineData("Letthem-28eatcake", true, 7, -28, 3)]
        [InlineData("127", true, 0, 127, 3)] // max
        [InlineData("-128", true, 0, -128, 4)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseCustomCultureByteArrayToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseSByte(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("๑๑๑", true, 0, 111, 9)]
        [InlineData("เรื่องเหลวไหล๒๗", true, 39, 27, 6)]
        [InlineData("๕๖กขฃคฅฆง", true, 0, 56, 6)]
        [InlineData("ที่เล็กที่สุดของประเภทนี้คือลบ๑๒๘.", true, 84, -128, 15)]
        [InlineData("ปล่อยให้พวกเขา ลบ๒๘ กินเค้ก", true, 43, -28, 12)]
        [InlineData("๑๒๗", true, 0, 127, 9)] // max
        [InlineData("ลบ๑๒๘", true, 0, -128, 15)] // min
        [InlineData("ลบA", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am ๑", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("ลป๑", false, 0, 0, 0)] // 
        public unsafe void ParseCustomCultureThaiByteArrayToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            bool result = Internal.InternalParser.TryParseSByte(UtfEncode(text, false), index, 'R', s_thaiEncoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh27", true, 9, 27, 2)]
        [InlineData("53abcdefg", true, 0, 53, 2)]
        [InlineData("The smallest of this type is -128.", true, 29, -128, 4)]
        [InlineData("Letthem-28eatcake", true, 7, -28, 3)]
        [InlineData("127", true, 0, 127, 3)] // max
        [InlineData("-128", true, 0, -128, 4)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8ByteArrayToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseSByte(UtfEncode(text, false), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh27", true, 9, 27, 2)]
        [InlineData("53abcdefg", true, 0, 53, 2)]
        [InlineData("The smallest of this type is -128.", true, 29, -128, 4)]
        [InlineData("Letthem-28eatcake", true, 7, -28, 3)]
        [InlineData("127", true, 0, 127, 3)] // max
        [InlineData("-128", true, 0, -128, 4)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseSByte(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh27", true, 9, 27, 2)]
        [InlineData("53abcdefg", true, 0, 53, 2)]
        [InlineData("The smallest of this type is -128.", true, 29, -128, 4)]
        [InlineData("Letthem-28eatcake", true, 7, -28, 3)]
        [InlineData("127", true, 0, 127, 3)] // max
        [InlineData("-128", true, 0, -128, 4)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseSByte(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh27", true, 18, 27, 4)]
        [InlineData("53abcdefg", true, 0, 53, 4)]
        [InlineData("The smallest of this type is -128.", true, 58, -128, 8)]
        [InlineData("Letthem-28eatcake", true, 14, -28, 6)]
        [InlineData("127", true, 0, 127, 6)] // max
        [InlineData("-128", true, 0, -128, 8)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16ByteArrayToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseSByte(UtfEncode(text, true), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh27", true, 18, 27, 4)]
        [InlineData("53abcdefg", true, 0, 53, 4)]
        [InlineData("The smallest of this type is -128.", true, 58, -128, 8)]
        [InlineData("Letthem-28eatcake", true, 14, -28, 6)]
        [InlineData("127", true, 0, 127, 6)] // max
        [InlineData("-128", true, 0, -128, 8)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseSByte(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh27", true, 18, 27, 4)]
        [InlineData("53abcdefg", true, 0, 53, 4)]
        [InlineData("The smallest of this type is -128.", true, 58, -128, 8)]
        [InlineData("Letthem-28eatcake", true, 14, -28, 6)]
        [InlineData("127", true, 0, 127, 6)] // max
        [InlineData("-128", true, 0, -128, 8)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("128", false, 0, 0, 0)] // positive overflow test
        [InlineData("-129", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToSbyte(string text, bool expectSuccess, int index, sbyte expectedValue, int expectedBytesConsumed)
        {
            sbyte parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseSByte(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region short

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh2767", true, 9, 2767, 4)]
        [InlineData("5333abcdefg", true, 0, 5333, 4)]
        [InlineData("The smallest of this type is -32768.", true, 29, -32768, 6)]
        [InlineData("Letthem-2768eatcake", true, 7, -2768, 5)]
        [InlineData("32767", true, 0, 32767, 5)] // max
        [InlineData("-32768", true, 0, -32768, 6)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseCustomCultureByteArrayToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseInt16(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("๑๑๑", true, 0, 111, 9)]
        [InlineData("เรื่องเหลวไหล๒๗", true, 39, 27, 6)]
        [InlineData("๕๖กขฃคฅฆง", true, 0, 56, 6)]
        [InlineData("ที่เล็กที่สุดของประเภทนี้คือลบ๑๒๘.", true, 84, -128, 15)]
        [InlineData("ปล่อยให้พวกเขา ลบ๒๘ กินเค้ก", true, 43, -28, 12)]
        [InlineData("๑๒๗", true, 0, 127, 9)] // max
        [InlineData("ลบ๑๒๘", true, 0, -128, 15)] // min
        [InlineData("ลบA", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am ๑", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("ลป๑", false, 0, 0, 0)] // 
        public unsafe void ParseCustomCultureThaiByteArrayToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            bool result = Internal.InternalParser.TryParseInt16(UtfEncode(text, false), index, 'R', s_thaiEncoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh2767", true, 9, 2767, 4)]
        [InlineData("5333abcdefg", true, 0, 5333, 4)]
        [InlineData("The smallest of this type is -32768.", true, 29, -32768, 6)]
        [InlineData("Letthem-2768eatcake", true, 7, -2768, 5)]
        [InlineData("32767", true, 0, 32767, 5)] // max
        [InlineData("-32768", true, 0, -32768, 6)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8ByteArrayToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseInt16(UtfEncode(text, false), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh2767", true, 9, 2767, 4)]
        [InlineData("5333abcdefg", true, 0, 5333, 4)]
        [InlineData("The smallest of this type is -32768.", true, 29, -32768, 6)]
        [InlineData("Letthem-2768eatcake", true, 7, -2768, 5)]
        [InlineData("32767", true, 0, 32767, 5)] // max
        [InlineData("-32768", true, 0, -32768, 6)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseInt16(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh2767", true, 9, 2767, 4)]
        [InlineData("5333abcdefg", true, 0, 5333, 4)]
        [InlineData("The smallest of this type is -32768.", true, 29, -32768, 6)]
        [InlineData("Letthem-2768eatcake", true, 7, -2768, 5)]
        [InlineData("32767", true, 0, 32767, 5)] // max
        [InlineData("-32768", true, 0, -32768, 6)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseInt16(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh2767", true, 18, 2767, 8)]
        [InlineData("5333abcdefg", true, 0, 5333, 8)]
        [InlineData("The smallest of this type is -32768.", true, 58, -32768, 12)]
        [InlineData("Letthem-2768eatcake", true, 14, -2768, 10)]
        [InlineData("32767", true, 0, 32767, 10)] // max
        [InlineData("-32768", true, 0, -32768, 12)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16ByteArrayToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseInt16(UtfEncode(text, true), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh2767", true, 18, 2767, 8)]
        [InlineData("5333abcdefg", true, 0, 5333, 8)]
        [InlineData("The smallest of this type is -32768.", true, 58, -32768, 12)]
        [InlineData("Letthem-2768eatcake", true, 14, -2768, 10)]
        [InlineData("32767", true, 0, 32767, 10)] // max
        [InlineData("-32768", true, 0, -32768, 12)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseInt16(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh2767", true, 18, 2767, 8)]
        [InlineData("5333abcdefg", true, 0, 5333, 8)]
        [InlineData("The smallest of this type is -32768.", true, 58, -32768, 12)]
        [InlineData("Letthem-2768eatcake", true, 14, -2768, 10)]
        [InlineData("32767", true, 0, 32767, 10)] // max
        [InlineData("-32768", true, 0, -32768, 12)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("32768", false, 0, 0, 0)] // positive overflow test
        [InlineData("-32769", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToShort(string text, bool expectSuccess, int index, short expectedValue, int expectedBytesConsumed)
        {
            short parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseInt16(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region int

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh147483647", true, 9, 147483647, 9)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 9)]
        [InlineData("The smallest of this type is -2147483648.", true, 29, -2147483648, 11)]
        [InlineData("Letthem-147483648eatcake", true, 7, -147483648, 10)]
        [InlineData("2147483647", true, 0, 2147483647, 10)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseCustomCultureByteArrayToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseInt32(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("๑๑๑", true, 0, 111, 9)]
        [InlineData("เรื่องเหลวไหล๒๗", true, 39, 27, 6)]
        [InlineData("๕๖กขฃคฅฆง", true, 0, 56, 6)]
        [InlineData("ที่เล็กที่สุดของประเภทนี้คือลบ๑๒๘.", true, 84, -128, 15)]
        [InlineData("ปล่อยให้พวกเขา ลบ๒๘ กินเค้ก", true, 43, -28, 12)]
        [InlineData("๑๒๗", true, 0, 127, 9)] // max
        [InlineData("ลบ๑๒๘", true, 0, -128, 15)] // min
        [InlineData("ลบA", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am ๑", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("ลป๑", false, 0, 0, 0)] // 
        public unsafe void ParseCustomCultureThaiByteArrayToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            bool result = Internal.InternalParser.TryParseInt32(UtfEncode(text, false), index, 'R', s_thaiEncoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh147483647", true, 9, 147483647, 9)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 9)]
        [InlineData("The smallest of this type is -2147483648.", true, 29, -2147483648, 11)]
        [InlineData("Letthem-147483648eatcake", true, 7, -147483648, 10)]
        [InlineData("2147483647", true, 0, 2147483647, 10)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8ByteArrayToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseInt32(UtfEncode(text, false), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh147483647", true, 9, 147483647, 9)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 9)]
        [InlineData("The smallest of this type is -2147483648.", true, 29, -2147483648, 11)]
        [InlineData("Letthem-147483648eatcake", true, 7, -147483648, 10)]
        [InlineData("2147483647", true, 0, 2147483647, 10)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseInt32(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh147483647", true, 9, 147483647, 9)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 9)]
        [InlineData("The smallest of this type is -2147483648.", true, 29, -2147483648, 11)]
        [InlineData("Letthem-147483648eatcake", true, 7, -147483648, 10)]
        [InlineData("2147483647", true, 0, 2147483647, 10)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 11)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseInt32(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh147483647", true, 18, 147483647, 18)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 18)]
        [InlineData("The smallest of this type is -2147483648.", true, 58, -2147483648, 22)]
        [InlineData("Letthem-147483648eatcake", true, 14, -147483648, 20)]
        [InlineData("2147483647", true, 0, 2147483647, 20)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 22)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16ByteArrayToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseInt32(UtfEncode(text, true), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh147483647", true, 18, 147483647, 18)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 18)]
        [InlineData("The smallest of this type is -2147483648.", true, 58, -2147483648, 22)]
        [InlineData("Letthem-147483648eatcake", true, 14, -147483648, 20)]
        [InlineData("2147483647", true, 0, 2147483647, 20)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 22)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseInt32(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh147483647", true, 18, 147483647, 18)]
        [InlineData("474753647abcdefg", true, 0, 474753647, 18)]
        [InlineData("The smallest of this type is -2147483648.", true, 58, -2147483648, 22)]
        [InlineData("Letthem-147483648eatcake", true, 14, -147483648, 20)]
        [InlineData("2147483647", true, 0, 2147483647, 20)] // max
        [InlineData("-2147483648", true, 0, -2147483648, 22)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("2147483648", false, 0, 0, 0)] // positive overflow test
        [InlineData("-2147483649", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToInt(string text, bool expectSuccess, int index, int expectedValue, int expectedBytesConsumed)
        {
            int parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseInt32(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region long

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh223372036854775807", true, 9, 223372036854775807, 18)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 18)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 29, -9223372036854775808, 20)]
        [InlineData("Letthem-223372036854775808eatcake", true, 7, -223372036854775808, 19)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseCustomCultureByteArrayToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;            
            bool result = Internal.InternalParser.TryParseInt64(UtfEncode(text, false), index, 'R', s_utf8Encoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("๑๑๑", true, 0, 111, 9)]
        [InlineData("เรื่องเหลวไหล๒๗", true, 39, 27, 6)]
        [InlineData("๕๖กขฃคฅฆง", true, 0, 56, 6)]
        [InlineData("ที่เล็กที่สุดของประเภทนี้คือลบ๑๒๘.", true, 84, -128, 15)]
        [InlineData("ปล่อยให้พวกเขา ลบ๒๘ กินเค้ก", true, 43, -28, 12)]
        [InlineData("๑๒๗", true, 0, 127, 9)] // max
        [InlineData("ลบ๑๒๘", true, 0, -128, 15)] // min
        [InlineData("ลบA", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am ๑", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("ลป๑", false, 0, 0, 0)] // 
        public unsafe void ParseCustomCultureThaiByteArrayToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            bool result = Internal.InternalParser.TryParseInt64(UtfEncode(text, false), index, 'R', s_thaiEncoding, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh223372036854775807", true, 9, 223372036854775807, 18)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 18)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 29, -9223372036854775808, 20)]
        [InlineData("Letthem-223372036854775808eatcake", true, 7, -223372036854775808, 19)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8ByteArrayToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseInt64(UtfEncode(text, false), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh223372036854775807", true, 9, 223372036854775807, 18)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 18)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 29, -9223372036854775808, 20)]
        [InlineData("Letthem-223372036854775808eatcake", true, 7, -223372036854775808, 19)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf8SpanToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
			var span = UtfEncode(text, false).Slice(index);
            bool result = Internal.InternalParser.TryParseInt64(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 3)]
        [InlineData("blahblahh223372036854775807", true, 9, 223372036854775807, 18)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 18)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 29, -9223372036854775808, 20)]
        [InlineData("Letthem-223372036854775808eatcake", true, 7, -223372036854775808, 19)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 19)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 20)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf8ByteStarToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseInt64(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh223372036854775807", true, 18, 223372036854775807, 36)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 36)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 58, -9223372036854775808, 40)]
        [InlineData("Letthem-223372036854775808eatcake", true, 14, -223372036854775808, 38)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 38)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 40)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16ByteArrayToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
            bool result = Internal.InternalParser.TryParseInt64(UtfEncode(text, true), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh223372036854775807", true, 18, 223372036854775807, 36)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 36)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 58, -9223372036854775808, 40)]
        [InlineData("Letthem-223372036854775808eatcake", true, 14, -223372036854775808, 38)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 38)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 40)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public void ParseUtf16SpanToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;
			var span = UtfEncode(text, true).Slice(index);
            bool result = Internal.InternalParser.TryParseInt64(span, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData("111", true, 0, 111, 6)]
        [InlineData("blahblahh223372036854775807", true, 18, 223372036854775807, 36)]
        [InlineData("555642036585755426abcdefg", true, 0, 555642036585755426, 36)]
        [InlineData("The smallest of this type is -9223372036854775808.", true, 58, -9223372036854775808, 40)]
        [InlineData("Letthem-223372036854775808eatcake", true, 14, -223372036854775808, 38)]
        [InlineData("9223372036854775807", true, 0, 9223372036854775807, 38)] // max
        [InlineData("-9223372036854775808", true, 0, -9223372036854775808, 40)] // min
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("9223372036854775808", false, 0, 0, 0)] // positive overflow test
        [InlineData("-9223372036854775809", false, 0, 0, 0)] // negative overflow test
        public unsafe void ParseUtf16ByteStarToLong(string text, bool expectSuccess, int index, long expectedValue, int expectedBytesConsumed)
        {
            long parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf16;

            byte[] textBytes = UtfEncode(text, true);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseInt64(arrayPointer, index, textBytes.Length, 'N', fd,
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region float

		// [Theory]
        [InlineData(".1728", true, 0, 0.1728f, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110f, 8)]
        [InlineData("+98.7abcdefg", true, 0, 98.7f, 5)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001f, 14)]
        [InlineData("1.45e12", true, 0, 1.45e12f, 7)]
        [InlineData("1E-8", true, 0, 1e-8f, 4)]
        [InlineData("-3.402822E+38", true, 0, -3.402822E+38f, 13)] // min value
        [InlineData("3.402822E+38", true, 0, 3.402822E+38f, 12)] // max value
        [InlineData("Infinity", true, 0, float.PositiveInfinity, 8)]
        [InlineData("-Infinity", true, 0, float.NegativeInfinity, 9)]
        [InlineData("NaN", true, 0, float.NaN, 3)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1.6540654e100000", false, 0, 0, 0)] // overflow test
        public void ParseUtf8ByteArrayToFloat(string text, bool expectSuccess, int index, float expectedValue, int expectedBytesConsumed)
        {
            float parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseSingle(UtfEncode(text, false), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData(".1728", true, 0, 0.1728f, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110f, 8)]
        [InlineData("+98.7abcdefg", true, 0, 98.7f, 5)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001f, 14)]
        [InlineData("1.45e12", true, 0, 1.45e12f, 7)]
        [InlineData("1E-8", true, 0, 1e-8f, 4)]
        [InlineData("-3.402822E+38", true, 0, -3.402822E+38f, 13)] // min value
        [InlineData("3.402822E+38", true, 0, 3.402822E+38f, 12)] // max value
        [InlineData("Infinity", true, 0, float.PositiveInfinity, 8)]
        [InlineData("-Infinity", true, 0, float.NegativeInfinity, 9)]
        [InlineData("NaN", true, 0, float.NaN, 3)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1.6540654e100000", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToFloat(string text, bool expectSuccess, int index, float expectedValue, int expectedBytesConsumed)
        {
            float parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseSingle(arrayPointer, index, textBytes.Length, 'N', fd, 
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region double

		// [Theory]
        [InlineData(".1728", true, 0, 0.1728, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110, 8)]
        [InlineData("+98.7abcdefg", true, 0, 98.7, 5)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001, 14)]
        [InlineData("1.45e12", true, 0, 1.45e12, 7)]
        [InlineData("1E-8", true, 0, 1e-8, 4)]
        [InlineData("-1.79769313486231E+308", true, 0, -1.79769313486231E+308, 22)] // min value
        [InlineData("1.79769313486231E+308", true, 0, 1.79769313486231E+308, 21)] // max value
        [InlineData("Infinity", true, 0, double.PositiveInfinity, 8)]
        [InlineData("-Infinity", true, 0, double.NegativeInfinity, 9)]
        [InlineData("NaN", true, 0, double.NaN, 3)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1.6540654e100000", false, 0, 0, 0)] // overflow test
        public void ParseUtf8ByteArrayToDouble(string text, bool expectSuccess, int index, double expectedValue, int expectedBytesConsumed)
        {
            double parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;
            bool result = Internal.InternalParser.TryParseDouble(UtfEncode(text, false), index, 'N', fd, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

		// [Theory]
        [InlineData(".1728", true, 0, 0.1728, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110, 8)]
        [InlineData("+98.7abcdefg", true, 0, 98.7, 5)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001, 14)]
        [InlineData("1.45e12", true, 0, 1.45e12, 7)]
        [InlineData("1E-8", true, 0, 1e-8, 4)]
        [InlineData("-1.79769313486231E+308", true, 0, -1.79769313486231E+308, 22)] // min value
        [InlineData("1.79769313486231E+308", true, 0, 1.79769313486231E+308, 21)] // max value
        [InlineData("Infinity", true, 0, double.PositiveInfinity, 8)]
        [InlineData("-Infinity", true, 0, double.NegativeInfinity, 9)]
        [InlineData("NaN", true, 0, double.NaN, 3)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1.6540654e100000", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToDouble(string text, bool expectSuccess, int index, double expectedValue, int expectedBytesConsumed)
        {
            double parsedValue;
            int bytesConsumed;
            EncodingData fd = EncodingData.InvariantUtf8;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseDouble(arrayPointer, index, textBytes.Length, fd, 'N',
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

		#endregion

		#region bool
		
        // [Theory]
        [InlineData("blahblahhTrue", true, 9, true, 4)]
        [InlineData("trueacndasjfh", true, 0, true, 4)]
        [InlineData("LetthemFALSEeatcake", true, 7, false, 5)]
        [InlineData("false", true, 0, false, 5)]
        [InlineData("FaLsE", true, 0, false, 5)]
        [InlineData("0", true, 0, false, 1)]
        [InlineData("1", true, 0, true, 1)]
        [InlineData("-A", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        public unsafe void ParseBool(string text, bool expectSuccess, int index, bool expectedValue, int expectedBytesConsumed)
        {
		    bool result;
            bool parsedValue;
            int bytesConsumed;
			var utf8String = new Utf8String(text);
			byte[] utf8Bytes = utf8String.CopyBytes();
			ReadOnlySpan<byte> utf8BytesSlice = new ReadOnlySpan<byte>(utf8Bytes);

			// System.String
			result = Internal.InternalParser.TryParseBoolean(text, index, 'N', out parsedValue, out bytesConsumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);

			// Utf8String
			result = Internal.InternalParser.TryParseBoolean(utf8String.Substring(index), 'N', out parsedValue, out bytesConsumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);

			// byte[]
			result = Internal.InternalParser.TryParseBoolean(utf8Bytes, index, 'N', EncodingData.InvariantUtf8, out parsedValue, out bytesConsumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);

			// ReadOnlySpan<byte>
			result = Internal.InternalParser.TryParseBoolean(utf8Bytes.Slice(index), 'N', EncodingData.InvariantUtf8, out parsedValue, out bytesConsumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);

			// byte*
            fixed (byte* arrayPointer = utf8Bytes)
            {
                result = Internal.InternalParser.TryParseBoolean(arrayPointer, index, utf8Bytes.Length, EncodingData.InvariantUtf8, 'N',
                    out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

        #endregion

		#region decimal

        // [Theory]
        [InlineData(".1728", true, 0, 0.1728, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110, 8)]
        [InlineData("+98.25abcdefg", true, 0, 98.25, 6)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001, 14)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1111111111111111111111111111111111111111111111111111111111", false, 0, 0, 0)] // overflow test
        public void ParseUtf8ByteArrayToDecimal(string text, bool expectSuccess, int index, decimal expectedValue, int expectedBytesConsumed)
        {
            decimal parsedValue;
            int bytesConsumed;
            bool result = Internal.InternalParser.TryParseDecimal(UtfEncode(text, false), index, out parsedValue, out bytesConsumed);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

        // [Theory]
        [InlineData(".1728", true, 0, 0.1728, 5)]
        [InlineData("blahblahh175.1110", true, 9, 175.1110, 8)]
        [InlineData("+98.25abcdefg", true, 0, 98.25, 6)]
        [InlineData("A small float is -0.10000000001", true, 17, -0.10000000001, 14)]
        [InlineData("I am 1", false, 0, 0, 0)] // invalid character test
        [InlineData("1111111111111111111111111111111111111111111111111111111111", false, 0, 0, 0)] // overflow test
        public unsafe void ParseUtf8ByteStarToDecimal(string text, bool expectSuccess, int index, decimal expectedValue, int expectedBytesConsumed)
        {
            byte[] utf8Array = UtfEncode(text, false);

            decimal parsedValue;
            int bytesConsumed;
            fixed (byte* arrayPointer = utf8Array)
            {
                bool result = Internal.InternalParser.TryParseDecimal(arrayPointer, index, utf8Array.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }

        #endregion

        #region uri
        // [Theory]
        [InlineData("http://www.example.com/", true, 0, "http://www.example.com/", 23)]
        [InlineData("https://www.example.org/important.php?true=true", true, 0, "https://www.example.org/important.php?true=true", 47)]
        [InlineData("http://msw", true, 0, "http://msw", 10)]
        [InlineData("ftp://example.org", true, 0, "ftp://example.org", 17)]
        [InlineData("file:///C:\\Users", true, 0, "file:///C:\\Users", 16)]
        [InlineData("C:\\Users", true, 0, "C:\\Users", 8)]
        [InlineData("rtsp://192.168.1.1", true, 0, "rtsp://192.168.1.1", 18)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", true, 15, "http://www.example.org", 22)]
        [InlineData("http://&5", false, 0, "", 0)]
        [InlineData("(*)$#*(", false, 0, "", 0)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", false, 4, "", 0)] // bad index
        [InlineData("197", false, 0, "", 0)]
        [InlineData("://////888.4.4.4", false, 0, "", 0)]
        public void ParseUtf8ByteArrayToUri(string text, bool expectSuccess, int index, string expectedValue, int expectedBytesConsumed)
        {
            Uri parsedValue;
            int bytesConsumed;
            bool result = Internal.InternalParser.TryParseUri(UtfEncode(text, false), index, out parsedValue, out bytesConsumed);


            Assert.Equal(expectSuccess, result);
            if (expectedValue != "")
                Assert.Equal(new Uri(expectedValue), parsedValue);
            else
                Assert.Equal(null, parsedValue);
            Assert.Equal(expectedBytesConsumed, bytesConsumed);
        }

        // [Theory]
        [InlineData("http://www.example.com/", true, 0, "http://www.example.com/", 23)]
        [InlineData("https://www.example.org/important.php?true=true", true, 0, "https://www.example.org/important.php?true=true", 47)]
        [InlineData("http://msw", true, 0, "http://msw", 10)]
        [InlineData("ftp://example.org", true, 0, "ftp://example.org", 17)]
        [InlineData("file:///C:\\Users", true, 0, "file:///C:\\Users", 16)]
        [InlineData("C:\\Users", true, 0, "C:\\Users", 8)]
        [InlineData("rtsp://192.168.1.1", true, 0, "rtsp://192.168.1.1", 18)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", true, 15, "http://www.example.org", 22)]
        [InlineData("http://&5", false, 0, "", 0)]
        [InlineData("(*)$#*(", false, 0, "", 0)]
        [InlineData("HTTP 1.1 / GET http://www.example.org; ...", false, 4, "", 0)] // bad index
        [InlineData("197", false, 0, "", 0)]
        [InlineData("://////888.4.4.4", false, 0, "", 0)]
        public unsafe void ParseUtf8ByteStarToUri(string text, bool expectSuccess, int index, string expectedValue, int expectedBytesConsumed)
        {
            Uri parsedValue;
            int bytesConsumed;

            byte[] textBytes = UtfEncode(text, false);
            fixed (byte* arrayPointer = textBytes)
            {
                bool result = Internal.InternalParser.TryParseUri(arrayPointer, index, textBytes.Length, out parsedValue, out bytesConsumed);

                Assert.Equal(expectSuccess, result);
                if (expectedValue != "")
                    Assert.Equal(new Uri(expectedValue), parsedValue);
                else
                    Assert.Equal(null, parsedValue);
                Assert.Equal(expectedBytesConsumed, bytesConsumed);
            }
        }
        #endregion
	}
}