<#@ template hostspecific="false" language="C#" #>
<#@ output extension=".cs" #>
<#@ assembly name="System.Numerics.dll" #>
<#@ import namespace="System.Text" #>
<#@ import namespace="System.Collections.Generic" #>
<#@ import namespace="System.Numerics" #>
<#

List<TypeToParse> unsignedTypes = new List<TypeToParse>();

unsignedTypes.Add(new TypeToParse {
    PrimitiveName = "byte",
    ClassName = "Byte",
    MinValueText = byte.MinValue.ToString(),
    MaxValueText = byte.MaxValue.ToString(),
    MinValueTextHex = byte.MinValue.ToString("X"),
    MaxValueTextHex = byte.MaxValue.ToString("X")
});

unsignedTypes.Add(new TypeToParse {
    PrimitiveName = "ushort",
    ClassName = "UInt16",
    MinValueText = ushort.MinValue.ToString(),
    MaxValueText = ushort.MaxValue.ToString(),
    MinValueTextHex = ushort.MinValue.ToString("X"),
    MaxValueTextHex = ushort.MaxValue.ToString("X")
});

unsignedTypes.Add(new TypeToParse {
    PrimitiveName = "uint",
    ClassName = "UInt32",
    MinValueText = uint.MinValue.ToString(),
    MaxValueText = uint.MaxValue.ToString(),
    MinValueTextHex = uint.MinValue.ToString("X"),
    MaxValueTextHex = uint.MaxValue.ToString("X")
});

unsignedTypes.Add(new TypeToParse {
    PrimitiveName = "ulong",
    ClassName = "UInt64",
    MinValueText = ulong.MinValue.ToString(),
    MaxValueText = ulong.MaxValue.ToString(),
    MinValueTextHex = ulong.MinValue.ToString("X"),
    MaxValueTextHex = ulong.MaxValue.ToString("X")
});

List<TypeToParse> signedTypes = new List<TypeToParse>();

signedTypes.Add(new TypeToParse {
    PrimitiveName = "sbyte",
    ClassName = "SByte",
    MinValueText = sbyte.MinValue.ToString(),
    MaxValueText = sbyte.MaxValue.ToString(),
    MinValueTextHex = sbyte.MinValue.ToString("X"),
    MaxValueTextHex = sbyte.MaxValue.ToString("X")
});

signedTypes.Add(new TypeToParse {
    PrimitiveName = "short",
    ClassName = "Int16",
    MinValueText = short.MinValue.ToString(),
    MaxValueText = short.MaxValue.ToString(),
    MinValueTextHex = short.MinValue.ToString("X"),
    MaxValueTextHex = short.MaxValue.ToString("X")
});

signedTypes.Add(new TypeToParse {
    PrimitiveName = "int",
    ClassName = "Int32",
    MinValueText = int.MinValue.ToString(),
    MaxValueText = int.MaxValue.ToString(),
    MinValueTextHex = int.MinValue.ToString("X"),
    MaxValueTextHex = int.MaxValue.ToString("X")
});

signedTypes.Add(new TypeToParse {
    PrimitiveName = "long",
    ClassName = "Int64",
    MinValueText = long.MinValue.ToString(),
    MaxValueText = long.MaxValue.ToString(),
    MinValueTextHex = long.MinValue.ToString("X"),
    MaxValueTextHex = long.MaxValue.ToString("X")
});
#>
// NOTE: This file is generated via a T4 template. Please do not edit this file directly. Any changes should be made
// in PrimitiveParserIntegerTests.tt.

using Xunit;

namespace System.Text.Primitives.Tests
{
    public partial class PrimitiveParserTests
    {
        private byte[] UtfEncode(string s, bool utf16)
        {
            if (utf16)
                return Encoding.Unicode.GetBytes(s);
            else
                return Encoding.UTF8.GetBytes(s);
        }       
         
        static Tuple<byte, int>[] s_utf8ParsingTrie = new Tuple<byte, int>[] {
            Tuple.Create((byte)17, 0x3004390D),
            Tuple.Create((byte)43, 18),
            Tuple.Create((byte)45, 19),
            Tuple.Create((byte)46, 20),
            Tuple.Create((byte)48, 21),
            Tuple.Create((byte)49, 22),
            Tuple.Create((byte)50, 23),
            Tuple.Create((byte)51, 24),
            Tuple.Create((byte)52, 25),
            Tuple.Create((byte)53, 26),
            Tuple.Create((byte)54, 27),
            Tuple.Create((byte)55, 28),
            Tuple.Create((byte)56, 29),
            Tuple.Create((byte)57, 30),
            Tuple.Create((byte)69, 31),
            Tuple.Create((byte)73, 32),
            Tuple.Create((byte)78, 33),
            Tuple.Create((byte)101, 34),
            Tuple.Create((byte)0, 14),
            Tuple.Create((byte)0, 13),
            Tuple.Create((byte)0, 10),
            Tuple.Create((byte)0, 0),
            Tuple.Create((byte)0, 1),
            Tuple.Create((byte)0, 2),
            Tuple.Create((byte)0, 3),
            Tuple.Create((byte)0, 4),
            Tuple.Create((byte)0, 5),
            Tuple.Create((byte)0, 6),
            Tuple.Create((byte)0, 7),
            Tuple.Create((byte)0, 8),
            Tuple.Create((byte)0, 9),
            Tuple.Create((byte)0, 16),
            Tuple.Create((byte)0, 12),
            Tuple.Create((byte)0, 15),
            Tuple.Create((byte)0, 16),
        };

        static Tuple<byte, int>[] s_thais_utf8ParsingTrie = new Tuple<byte, int>[] {
            Tuple.Create((byte)4, 0),
            Tuple.Create((byte)43, 5),
            Tuple.Create((byte)69, 6),
            Tuple.Create((byte)101, 7),
            Tuple.Create((byte)0xE0, 8),
            Tuple.Create((byte)0, 14),
            Tuple.Create((byte)0, 16),
            Tuple.Create((byte)0, 16),
            Tuple.Create((byte)2, 0),
            Tuple.Create((byte)0xB8, 11),
            Tuple.Create((byte)0xB9, 15),
            Tuple.Create((byte)3, 0),
            Tuple.Create((byte)0x88, 27),
            Tuple.Create((byte)0xA5, 28),
            Tuple.Create((byte)0xAA, 29),
            Tuple.Create((byte)11, -1878877941 /* 0x9002990B */),
            Tuple.Create((byte)0x84, 30),
            Tuple.Create((byte)0x90, 31),
            Tuple.Create((byte)0x91, 32),
            Tuple.Create((byte)0x92, 33),
            Tuple.Create((byte)0x93, 34),
            Tuple.Create((byte)0x94, 35),
            Tuple.Create((byte)0x95, 36),
            Tuple.Create((byte)0x96, 37),
            Tuple.Create((byte)0x97, 38),
            Tuple.Create((byte)0x98, 39),
            Tuple.Create((byte)0x99, 40),
            Tuple.Create((byte)0, 10),
            Tuple.Create((byte)0, 13),
            Tuple.Create((byte)0, 12),
            Tuple.Create((byte)0, 15),
            Tuple.Create((byte)0, 0),
            Tuple.Create((byte)0, 1),
            Tuple.Create((byte)0, 2),
            Tuple.Create((byte)0, 3),
            Tuple.Create((byte)0, 4),
            Tuple.Create((byte)0, 5),
            Tuple.Create((byte)0, 6),
            Tuple.Create((byte)0, 7),
            Tuple.Create((byte)0, 8),
            Tuple.Create((byte)0, 9),
        };

        static byte[][] s_utf8digitsAndSymbols = new byte[][] {
            new byte[] { 48, },
            new byte[] { 49, },
            new byte[] { 50, },
            new byte[] { 51, },
            new byte[] { 52, },
            new byte[] { 53, },
            new byte[] { 54, },
            new byte[] { 55, },
            new byte[] { 56, },
            new byte[] { 57, }, // digit 9
            new byte[] { 46, }, // decimal separator
            new byte[] { 44, }, // group separator
            new byte[] { 73, 110, 102, 105, 110, 105, 116, 121, },
            new byte[] { 45, }, // minus sign
            new byte[] { 43, }, // plus sign
            new byte[] { 78, 97, 78, }, // NaN
            new byte[] { 69, }, // E
            new byte[] { 101, }, // e
        };

        static byte[][] s_thaiUtf8DigitsAndSymbols = new byte[][]
        {
            new byte[] { 0xe0, 0xb9, 0x90 }, new byte[] { 0xe0, 0xb9, 0x91 }, new byte[] { 0xe0, 0xb9, 0x92 },
            new byte[] { 0xe0, 0xb9, 0x93 }, new byte[] { 0xe0, 0xb9, 0x94 }, new byte[] { 0xe0, 0xb9, 0x95 }, new byte[] { 0xe0, 0xb9, 0x96 },
            new byte[] { 0xe0, 0xb9, 0x97 }, new byte[] { 0xe0, 0xb9, 0x98 }, new byte[] { 0xe0, 0xb9, 0x99 }, new byte[] { 0xE0, 0xB8, 0x88, 0xE0, 0xB8, 0x94 }, null,
            new byte[] { 0xE0, 0xB8, 0xAA, 0xE0, 0xB8, 0xB4, 0xE0, 0xB9, 0x88, 0xE0, 0xB8, 0x87, 0xE0, 0xB8, 0x97, 0xE0, 0xB8, 0xB5, 0xE0, 0xB9, 0x88, 0xE0, 0xB9, 0x83,
                0xE0, 0xB8, 0xAB, 0xE0, 0xB8, 0x8D, 0xE0, 0xB9, 0x88, 0xE0, 0xB9, 0x82, 0xE0, 0xB8, 0x95, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0xAB, 0xE0, 0xB8, 0xA5, 0xE0,
                0xB8, 0xB7, 0xE0, 0xB8, 0xAD, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0x81, 0xE0, 0xB8, 0xB4, 0xE0, 0xB8, 0x99 },
            new byte[] { 0xE0, 0xB8, 0xA5, 0xE0, 0xB8, 0x9A }, new byte[] { 43 }, new byte[] { 0xE0, 0xB9, 0x84, 0xE0, 0xB8, 0xA1, 0xE0, 0xB9, 0x88, 0xE0, 0xB9,
                0x83, 0xE0, 0xB8, 0x8A, 0xE0, 0xB9, 0x88, 0xE0, 0xB8, 0x95, 0xE0, 0xB8, 0xB1, 0xE0, 0xB8, 0xA7, 0xE0, 0xB9, 0x80, 0xE0, 0xB8, 0xA5, 0xE0, 0xB8, 0x82 },
            new byte[] { 69 }, new byte[] { 101 },
        };
            
        static TextEncoder s_thaiEncoding = new TextEncoder(s_thaiUtf8DigitsAndSymbols, TextEncoder.InvariantUtf8);

        static TextEncoder s_utf8Encoding = new TextEncoder(s_utf8digitsAndSymbols, TextEncoder.InvariantUtf8);

<#
    foreach (TypeToParse unsignedType in unsignedTypes)
    {
        BigInteger overflowValue = BigInteger.Parse(unsignedType.MaxValueText) + 1;

        string randValueText = GenerateRandomIntegerText(unsignedType.MaxValueText.Length - 1);
        string randValueTextHex = GenerateRandomIntegerTextHex(unsignedType.MaxValueTextHex.Length - 1);
#>
        #region <#= unsignedType.PrimitiveName #>

        [Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("<#= randValueText #>abhced", true, <#= randValueText #>, <#= randValueText.Length #>)]
        [InlineData("<#= unsignedType.MinValueText #>", true, <#= unsignedType.MinValueText #>, <#= unsignedType.MinValueText.Length #>)] // min value
        [InlineData("<#= unsignedType.MaxValueText #>", true, <#= unsignedType.MaxValueText #>, <#= unsignedType.MaxValueText.Length #>)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue.ToString() #>", false, 0, 0)] // overflow test
        public unsafe void Parse<#= unsignedType.ClassName #>Dec(string text, bool expectSuccess, <#= unsignedType.PrimitiveName #> expectedValue, int expectedConsumed)
        {
            <#= unsignedType.PrimitiveName #> parsedValue;
            int consumed;
            ReadOnlySpan<byte> utf8Span = UtfEncode(text, false);
            ReadOnlySpan<byte> utf16ByteSpan = UtfEncode(text, true);
            ReadOnlySpan<char> utf16CharSpan = utf16ByteSpan.NonPortableCast<byte, char>();
            byte[] textBytes = utf8Span.ToArray();
            char[] textChars = utf16CharSpan.ToArray();
            bool result;

            result = PrimitiveParser.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue, out consumed, 'G', TextEncoder.InvariantUtf8);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            result = PrimitiveParser.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            result = PrimitiveParser.InvariantUtf8.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf8.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (byte* arrayPointer = textBytes)
            {
                result = PrimitiveParser.InvariantUtf8.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf8.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }

            result = PrimitiveParser.TryParse<#= unsignedType.ClassName #>(utf16ByteSpan, out parsedValue, out consumed, 'G', TextEncoder.InvariantUtf16);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed * sizeof(char), consumed);

            result = PrimitiveParser.InvariantUtf16.TryParse<#= unsignedType.ClassName #>(utf16CharSpan, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf16.TryParse<#= unsignedType.ClassName #>(utf16CharSpan, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (char* arrayPointer = textChars)
            {
                result = PrimitiveParser.InvariantUtf16.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf16.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }
        }

        [Theory]
        [InlineData("af", true, 0xaf, 2)]
        [InlineData("<#= randValueTextHex #>ghijzl", true, 0x<#= randValueTextHex #>, <#= randValueTextHex.Length #>)]
        [InlineData("<#= unsignedType.MinValueTextHex #>", true, 0x<#= unsignedType.MinValueTextHex #>, <#= unsignedType.MinValueTextHex.Length #>)] // min value
        [InlineData("<#= unsignedType.MaxValueTextHex #>", true, 0x<#= unsignedType.MaxValueTextHex #>, <#= unsignedType.MaxValueTextHex.Length #>)] // max value
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue.ToString("X") #>", false, 0, 0)] // overflow test
        public unsafe void Parse<#= unsignedType.ClassName #>Hex(string text, bool expectSuccess, <#= unsignedType.ClassName #> expectedValue, int expectedConsumed)
        {
            <#= unsignedType.PrimitiveName #> parsedValue;
            int consumed;
            ReadOnlySpan<byte> utf8Span = UtfEncode(text, false);
            ReadOnlySpan<byte> utf16ByteSpan = UtfEncode(text, true);
            ReadOnlySpan<char> utf16CharSpan = utf16ByteSpan.NonPortableCast<byte, char>();
            byte[] textBytes = utf8Span.ToArray();
            char[] textChars = utf16CharSpan.ToArray();
            bool result;

            result = PrimitiveParser.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue, out consumed, 'X', TextEncoder.InvariantUtf8);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#= unsignedType.ClassName #>(utf8Span, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (byte* arrayPointer = textBytes)
            {
                result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }

            result = PrimitiveParser.TryParse<#= unsignedType.ClassName #>(utf16ByteSpan, out parsedValue, out consumed, 'X', TextEncoder.InvariantUtf16);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed * sizeof(char), consumed);

            result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#= unsignedType.ClassName #>(utf16CharSpan, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#= unsignedType.ClassName #>(utf16CharSpan, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (char* arrayPointer = textChars)
            {
                result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#= unsignedType.ClassName #>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }
        }

        #endregion

<#
        }
#>
<#
    foreach (TypeToParse signedType in signedTypes)
    {
        BigInteger overflowValue = BigInteger.Parse(signedType.MaxValueText) + 1;
        BigInteger underflowValue = BigInteger.Parse(signedType.MinValueText) - 1;

        // Signed hex parsing is just unsigned parsing with a cast afterward
        // Signed hex parsing cannot have underflow
        BigInteger overflowValueHex = overflowValue * 2;

        string randValueText = GenerateRandomIntegerText(signedType.MaxValueText.Length - 1);
        string randValueTextHex = GenerateRandomIntegerTextHex(signedType.MaxValueTextHex.Length - 1);
#>
        #region <#= signedType.PrimitiveName #>

        [Theory]
        [InlineData("111", true, 111, 3)]
        [InlineData("<#= randValueText #>abcdefg", true, <#= randValueText #>, <#= randValueText.Length #>)]
        [InlineData("<#= signedType.MaxValueText #>", true, <#= signedType.MaxValueText #>, <#= signedType.MaxValueText.Length #>)] // max
        [InlineData("<#= signedType.MinValueText #>", true, <#= signedType.MinValueText #>, <#= signedType.MinValueText.Length #>)] // min
        [InlineData("-A", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValue.ToString() #>", false, 0, 0)] // positive overflow test
        [InlineData("<#= underflowValue.ToString() #>", false, 0, 0)] // negative overflow test
        public unsafe void Parse<#= signedType.ClassName #>Dec(string text, bool expectSuccess, <#= signedType.PrimitiveName #> expectedValue, int expectedConsumed)
        {
            <#= signedType.PrimitiveName #> parsedValue;
            int consumed;
            ReadOnlySpan<byte> utf8Span = UtfEncode(text, false);
            ReadOnlySpan<byte> utf16ByteSpan = UtfEncode(text, true);
            ReadOnlySpan<char> utf16CharSpan = utf16ByteSpan.NonPortableCast<byte, char>();
            byte[] textBytes = utf8Span.ToArray();
            char[] textChars = utf16CharSpan.ToArray();
            bool result;

            result = PrimitiveParser.TryParse<#= signedType.ClassName #>(utf8Span, out parsedValue, out consumed, 'G', TextEncoder.InvariantUtf8);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            result = PrimitiveParser.TryParse<#= signedType.ClassName #>(utf8Span, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            result = PrimitiveParser.InvariantUtf8.TryParse<#=signedType.ClassName#>(utf8Span, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf8.TryParse<#=signedType.ClassName#>(utf8Span, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (byte* arrayPointer = textBytes)
            {
                result = PrimitiveParser.InvariantUtf8.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf8.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }

            result = PrimitiveParser.TryParse<#= signedType.ClassName #>(utf16ByteSpan, out parsedValue, out consumed, 'G', TextEncoder.InvariantUtf16);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed * sizeof(char), consumed);

            result = PrimitiveParser.InvariantUtf16.TryParse<#=signedType.ClassName#>(utf16CharSpan, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf16.TryParse<#=signedType.ClassName#>(utf16CharSpan, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (char* arrayPointer = textChars)
            {
                result = PrimitiveParser.InvariantUtf16.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf16.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }
        }

        [Theory]
        [InlineData("๑๑๑", true, 0, 111, 9)]
        [InlineData("เรื่องเหลวไหล๒๗", true, 39, 27, 6)]
        [InlineData("๕๖กขฃคฅฆง", true, 0, 56, 6)]
        [InlineData("ที่เล็กที่สุดของประเภทนี้คือลบ๑๒๘.", true, 84, -128, 15)]
        [InlineData("ปล่อยให้พวกเขา ลบ๒๘ กินเค้ก", true, 43, -28, 12)]
        [InlineData("๑๒๗", true, 0, 127, 9)] // max
        [InlineData("ลบ๑๒๘", true, 0, -128, 15)] // min
        [InlineData("ลบA", false, 0, 0, 0)] // invalid character after a sign
        [InlineData("I am ๑", false, 0, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("ลป๑", false, 0, 0, 0)] // 
        public unsafe void Parse<#= signedType.ClassName #>Thai(string text, bool expectSuccess, int index, <#= signedType.PrimitiveName #> expectedValue, int expectedConsumed)
        {
            <#= signedType.PrimitiveName #> parsedValue;
            int consumed;
            ReadOnlySpan<byte> utf8Span = UtfEncode(text, false);
            bool result;

            result = PrimitiveParser.TryParse<#= signedType.ClassName #>(utf8Span.Slice(index), out parsedValue, out consumed, 'G', s_thaiEncoding);

            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);
        }

        [Theory]
        [InlineData("1f", true, 0x1f, 2)]
        [InlineData("<#= randValueTextHex #>ghijzl", true, 0x<#= randValueTextHex #>, <#= randValueTextHex.Length #>)]
        [InlineData("<#= signedType.MaxValueTextHex #>", true, 0x<#= signedType.MaxValueTextHex #>, <#= signedType.MaxValueTextHex.Length #>)] // positive max
        [InlineData("<#= signedType.MinValueTextHex #>", true, -0x<#= signedType.MinValueTextHex #>, <#= signedType.MinValueTextHex.Length #>)] // negative min
        [InlineData("-G", false, 0, 0)] // invalid character after a sign
        [InlineData("I am 1", false, 0, 0)] // invalid character test
        [InlineData(" !", false, 0, 0)] // invalid character test w/ char < '0'
        [InlineData("<#= overflowValueHex.ToString("X") #>", false, 0, 0)] // overflow test
        public unsafe void Parse<#= signedType.ClassName #>Hex(string text, bool expectSuccess, <#= signedType.PrimitiveName #> expectedValue, int expectedConsumed)
        {
            <#= signedType.PrimitiveName #> parsedValue;
            int consumed;
            ReadOnlySpan<byte> utf8Span = UtfEncode(text, false);
            ReadOnlySpan<byte> utf16ByteSpan = UtfEncode(text, true);
            ReadOnlySpan<char> utf16CharSpan = utf16ByteSpan.NonPortableCast<byte, char>();
            byte[] textBytes = utf8Span.ToArray();
            char[] textChars = utf16CharSpan.ToArray();
            bool result;

            result = PrimitiveParser.TryParse<#= signedType.ClassName #>(utf8Span, out parsedValue, out consumed, 'X', TextEncoder.InvariantUtf8);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#=signedType.ClassName#>(utf8Span, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#=signedType.ClassName#>(utf8Span, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (byte* arrayPointer = textBytes)
            {
                result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue);

                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf8.Hex.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }

            result = PrimitiveParser.TryParse<#= signedType.ClassName #>(utf16ByteSpan, out parsedValue, out consumed, 'X', TextEncoder.InvariantUtf16);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed * sizeof(char), consumed);

            result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#=signedType.ClassName#>(utf16CharSpan, out parsedValue);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);

            result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#=signedType.ClassName#>(utf16CharSpan, out parsedValue, out consumed);
            Assert.Equal(expectSuccess, result);
            Assert.Equal(expectedValue, parsedValue);
            Assert.Equal(expectedConsumed, consumed);

            fixed (char* arrayPointer = textChars)
            {
                result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);

                result = PrimitiveParser.InvariantUtf16.Hex.TryParse<#=signedType.ClassName#>(arrayPointer, textBytes.Length, out parsedValue, out consumed);
                Assert.Equal(expectSuccess, result);
                Assert.Equal(expectedValue, parsedValue);
                Assert.Equal(expectedConsumed, consumed);
            }
        }

        #endregion

<#
        }
#>
    }
}
<#+
struct TypeToParse
{
    internal string PrimitiveName;
    internal string ClassName;
    internal string MinValueText;
    internal string MaxValueText;
    internal string MinValueTextHex;
    internal string MaxValueTextHex;
}
string GenerateRandomIntegerText(int length)
{
    StringBuilder randValueSB = new StringBuilder();
    Random r = new Random(55);
    for (int i=0; i < length; i++)
    {
        randValueSB.Append(r.Next(0, 10).ToString());
    }
    return randValueSB.ToString();
}
string GenerateRandomIntegerTextHex(int length)
{
    StringBuilder randValueSB = new StringBuilder();
    Random r = new Random(55);
    for (int i=0; i < length; i++)
    {
        randValueSB.Append(r.Next(0, 16).ToString("X"));
    }
    return randValueSB.ToString();
}
#>